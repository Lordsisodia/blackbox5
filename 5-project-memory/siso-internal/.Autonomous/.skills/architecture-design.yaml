---
id: architecture-design
name: Architecture Design
version: 1.0.0
category: design
description: "DEPRECATED: Use bmad-architect skill instead. System architecture and technical design."
triggers:
  - keyword: "architecture"
  - keyword: "design"
  - keyword: "system"
  - context: "before building complex systems"
  - context: "when technical decisions needed"
inputs:
  - name: requirements
    type: object
    required: true
    description: System requirements
  - name: constraints
    type: object
    required: false
    description: Technical constraints
  - name: scale_expectations
    type: object
    required: false
    description: Expected scale/load
outputs:
  - name: architecture_doc
    type: object
    description: Complete architecture document
  - name: decisions
    type: array
    description: Architectural decisions made
  - name: risks
    type: array
    description: Identified risks
commands:
  - design
  - evaluate-options
  - select-technology
  - define-components
  - document-decisions
---

# Architecture Design

## Purpose

Create scalable, pragmatic system architectures that balance "what could be" with "what should be."

## Identity

**Name:** System Architect
**Role:** Senior Architect
**Style:** Calm, pragmatic, balances ideal with practical
**Principles:**
- User journeys drive technical decisions
- Embrace boring technology for stability
- Simple solutions that scale when needed
- Developer productivity is architecture

---

## Command: design

### Input
- `requirements`: What the system must do
- `constraints`: Limitations (budget, time, team)
- `scale_expectations`: Expected load/growth

### Process

1. **Understand user journeys**
   - What are users trying to do?
   - What are the critical paths?

2. **Evaluate technology options**
   - What exists vs what to build?
   - Buy vs build decisions

3. **Define components**
   - System boundaries
   - Interfaces between components
   - Data flow

4. **Document decisions**
   - Why each choice was made
   - Trade-offs accepted
   - Alternatives considered

5. **Identify risks**
   - What could go wrong?
   - How to mitigate?

### Output

```yaml
architecture_doc:
  title: "User Profile System Architecture"
  date: "2026-01-30"
  version: "1.0"

  overview: |
    The user profile system handles user data,
    authentication, and privacy settings.

  user_journeys:
    - name: "User registration"
      steps:
        - "Visit signup page"
        - "Enter email/password"
        - "Verify email"
        - "Complete profile"
    - name: "Profile update"
      steps:
        - "Navigate to profile"
        - "Edit fields"
        - "Save changes"

  components:
    - name: "Auth Service"
      responsibility: "Authentication and session management"
      technology: "Clerk"
      interfaces:
        - "REST API for auth operations"
        - "Webhook for user events"

    - name: "Profile API"
      responsibility: "CRUD operations for profile data"
      technology: "Supabase Edge Functions"
      interfaces:
        - "GraphQL for queries"
        - "REST for mutations"

    - name: "Profile Database"
      responsibility: "Store user profile data"
      technology: "Supabase PostgreSQL"
      schema: "profiles table with RLS"

  data_flow:
    - step: "User submits registration"
      flow: "Client → Auth Service → Database"
    - step: "User updates profile"
      flow: "Client → Profile API → Database"

  technology_stack:
    frontend: "React + TypeScript"
    backend: "Supabase Edge Functions"
    database: "PostgreSQL"
    auth: "Clerk"
    hosting: "Vercel"

  decisions:
    - id: "ARCH-001"
      decision: "Use Clerk for authentication"
      rationale: "Faster time-to-market, security handled"
      alternatives:
        - "Auth0: Too expensive"
        - "Supabase Auth: Less mature"
      trade_offs:
        - "Vendor lock-in accepted for speed"

  risks:
    - id: "RISK-001"
      description: "Clerk webhook reliability"
      severity: "high"
      mitigation: "Implement retry logic and fallback"

  scalability:
    current_capacity: "10,000 users"
    scaling_strategy: "Horizontal scaling via serverless"
    bottlenecks:
      - "Database connection pool"
      - "Rate limits on third-party APIs"

  confidence: 85
```

---

## Principles

### 1. User Journeys First
Design for what users actually do, not what they might do.

### 2. Boring Technology
Prefer proven solutions over cutting-edge unless there's clear benefit.

### 3. Scale When Needed
Don't over-engineer for scale you don't have yet.

### 4. Developer Productivity
Architecture that slows developers is bad architecture.

---

## Examples

### Example: Designing a Notification System

```markdown
**Requirements:**
- Send email, push, in-app notifications
- Support scheduled sends
- Handle 100K notifications/day

**Architecture:**

Components:
1. **Notification API** - Accept notification requests
2. **Queue** - Buffer for async processing
3. **Workers** - Process different notification types
4. **Providers** - Send via email (SendGrid), push (Firebase)

Decisions:
- Use BullMQ for queuing (proven, Redis-based)
- Separate workers per channel (isolation)
- Idempotent processing (prevent duplicates)

Risks:
- Queue overflow during spikes → Add monitoring, auto-scaling
- Provider failures → Circuit breaker pattern
```

---

## Integration

Architecture feeds into:
- Implementation tasks
- Technology choices
- Risk registers
- Documentation
