#!/bin/bash
# bb5-status - System status overview
# Usage: bb5 status | bb5 status tasks | bb5 status queue | bb5 status goals

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BLACKBOX5_DIR="$PROJECT_ROOT/5-project-memory/blackbox5"
TASKS_DIR="$BLACKBOX5_DIR/tasks/active"
COMPLETED_TASKS_DIR="$BLACKBOX5_DIR/tasks/completed"
GOALS_DIR="$BLACKBOX5_DIR/goals/active"
QUEUE_FILE="$BLACKBOX5_DIR/.autonomous/agents/communications/queue.yaml"
TIMELINE_FILE="$BLACKBOX5_DIR/timeline.yaml"

COMMAND="${1:-overview}"

# Colors
if [ -t 1 ]; then
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    RED='\033[0;31m'
    MAGENTA='\033[0;35m'
    BOLD='\033[1m'
    NC='\033[0m'
else
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    RED=''
    MAGENTA=''
    BOLD=''
    NC=''
fi

# Helper functions
print_header() {
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    printf "  ${BOLD}%s${NC}\n" "$1"
    echo "═══════════════════════════════════════════════════════════════"
}

print_section() {
    printf "\n${CYAN}%s${NC}\n" "$1"
    printf "${CYAN}%s${NC}\n" "$(echo "$1" | sed 's/./─/g')"
}

print_stat() {
    printf "  %-30s ${BOLD}%s${NC}\n" "$1:" "$2"
}

print_bar() {
    local value=$1
    local max=$2
    local width=${3:-30}
    local color=${4:-$GREEN}

    if [ "$max" -eq 0 ]; then
        max=1
    fi

    local filled=$((width * value / max))
    local empty=$((width - filled))

    printf "${color}"
    printf "%${filled}s" | tr ' ' '█'
    printf "${NC}"
    printf "%${empty}s" | tr ' ' '░'
    printf " %d/%d\n" "$value" "$max"
}

# Count tasks by status
count_tasks_by_status() {
    local status=$1
    local count=0

    if [ -d "$TASKS_DIR" ]; then
        for task_dir in "$TASKS_DIR"/*/; do
            if [ -d "$task_dir" ]; then
                local task_file="$task_dir/task.md"
                if [ -f "$task_file" ]; then
                    local task_status=$(grep -i "^\s*status:" "$task_file" 2>/dev/null | head -1 | sed 's/.*status:[[:space:]]*//' | sed 's/\*//g' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
                    if [ "$task_status" = "$status" ]; then
                        ((count++))
                    fi
                fi
            fi
        done
    fi

    echo "$count"
}

# Count tasks by priority
count_tasks_by_priority() {
    local priority=$1
    local count=0

    if [ -d "$TASKS_DIR" ]; then
        for task_dir in "$TASKS_DIR"/*/; do
            if [ -d "$task_dir" ]; then
                local task_file="$task_dir/task.md"
                if [ -f "$task_file" ]; then
                    local task_priority=$(grep -i "^\s*priority:" "$task_file" 2>/dev/null | head -1 | sed 's/.*priority:[[:space:]]*//' | sed 's/\*//g' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
                    if [ "$task_priority" = "$(echo "$priority" | tr '[:upper:]' '[:lower:]')" ]; then
                        ((count++))
                    fi
                fi
            fi
        done
    fi

    echo "$count"
}

# Count claimed tasks
count_claimed_tasks() {
    local count=0

    if [ -d "$TASKS_DIR" ]; then
        for task_dir in "$TASKS_DIR"/*/; do
            if [ -d "$task_dir" ]; then
                local task_file="$task_dir/task.md"
                if [ -f "$task_file" ]; then
                    local owner=$(grep -i "^\s*owner:" "$task_file" 2>/dev/null | head -1 | sed 's/.*owner:[[:space:]]*//' | sed 's/\*//g' | tr -d '[:space:]')
                    if [ -n "$owner" ] && [ "$owner" != "null" ] && [ "$owner" != "~" ]; then
                        ((count++))
                    fi
                fi
            fi
        done
    fi

    echo "$count"
}

# Get last timeline event
get_last_timeline_event() {
    if [ -f "$TIMELINE_FILE" ]; then
        # Look for the most recent event or milestone
        local last_event=$(grep -A 5 "^  - date:" "$TIMELINE_FILE" 2>/dev/null | tail -20 | grep "entry:" | tail -1 | sed 's/.*entry:[[:space:]]*//' | sed 's/^"//;s/"$//')
        if [ -n "$last_event" ]; then
            echo "$last_event" | head -c 80
        else
            echo "No recent events"
        fi
    else
        echo "Timeline not found"
    fi
}

# Check if queue file is parseable
check_queue_health() {
    if [ ! -f "$QUEUE_FILE" ]; then
        echo "missing"
        return
    fi

    if python3 -c "import yaml; yaml.safe_load(open('$QUEUE_FILE'))" 2>/dev/null; then
        echo "healthy"
    else
        echo "corrupted"
    fi
}

# Get queue stats from queue.yaml
get_queue_stat() {
    local key=$1
    if [ -f "$QUEUE_FILE" ]; then
        grep -E "^\s+$key:" "$QUEUE_FILE" | tail -1 | sed 's/.*:[[:space:]]*//'
    else
        echo "0"
    fi
}

# Count goals by progress range
count_goals_by_progress() {
    local min=$1
    local max=$2
    local count=0

    if [ -d "$GOALS_DIR" ]; then
        for goal_file in "$GOALS_DIR"/*/goal.yaml; do
            if [ -f "$goal_file" ]; then
                local progress=$(grep -E "^\s+percentage:" "$goal_file" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//')
                if [ -n "$progress" ]; then
                    if [ "$progress" -ge "$min" ] && [ "$progress" -lt "$max" ]; then
                        ((count++))
                    fi
                fi
            fi
        done
    fi

    echo "$count"
}

# Count total active goals
count_active_goals() {
    local count=0
    if [ -d "$GOALS_DIR" ]; then
        count=$(find "$GOALS_DIR" -name "goal.yaml" -type f 2>/dev/null | wc -l)
    fi
    echo "$count"
}

# Get current run info
get_current_run() {
    local run_dir="$BLACKBOX5_DIR/.autonomous/runs"
    if [ -d "$run_dir" ]; then
        local latest=$(ls -1t "$run_dir" 2>/dev/null | grep -E "^run-" | head -1)
        if [ -n "$latest" ]; then
            echo "$latest"
        else
            echo "None"
        fi
    else
        echo "None"
    fi
}

# Calculate completion time stats
calculate_completion_stats() {
    local total_minutes=0
    local count=0

    # This is a simplified calculation - in reality you'd track actual completion times
    # For now, we'll use estimated_minutes from completed tasks
    if [ -f "$QUEUE_FILE" ]; then
        local completed=$(grep -c "status:\s*completed" "$QUEUE_FILE" 2>/dev/null || echo "0")
        local total_est=$(grep "total_estimated_minutes:" "$QUEUE_FILE" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//')
        if [ -n "$total_est" ] && [ "$completed" -gt 0 ]; then
            echo "$((total_est / completed))"
        else
            echo "N/A"
        fi
    else
        echo "N/A"
    fi
}

# Main overview display
show_overview() {
    print_header "BB5 System Status"

    local active_count=0
    local completed_count=0

    if [ -d "$TASKS_DIR" ]; then
        active_count=$(find "$TASKS_DIR" -maxdepth 1 -type d | grep -v "^$TASKS_DIR$" | wc -l)
    fi

    if [ -d "$COMPLETED_TASKS_DIR" ]; then
        completed_count=$(find "$COMPLETED_TASKS_DIR" -maxdepth 1 -type d 2>/dev/null | grep -v "^$COMPLETED_TASKS_DIR$" | wc -l)
    fi

    local pending_count=$(count_tasks_by_status "pending")
    local in_progress_count=$(count_tasks_by_status "in_progress")
    local blocked_count=$(count_tasks_by_status "blocked")
    local claimed_count=$(count_claimed_tasks)
    local unclaimed_count=$((active_count - claimed_count))

    local goals_count=$(count_active_goals)
    local current_run=$(get_current_run)
    local last_event=$(get_last_timeline_event)

    print_section "Task Summary"
    printf "  Active:    ${BOLD}%d${NC}  " "$active_count"
    print_bar "$active_count" $((active_count + completed_count))

    printf "  Completed: ${BOLD}%d${NC}  " "$completed_count"
    print_bar "$completed_count" $((active_count + completed_count)) 30 "$BLUE"

    print_section "Status Breakdown"
    print_stat "Pending" "$pending_count"
    print_stat "In Progress" "$in_progress_count"
    print_stat "Blocked" "$blocked_count"
    print_stat "Claimed" "$claimed_count"
    print_stat "Unclaimed" "$unclaimed_count"

    print_section "Goals & Runs"
    print_stat "Active Goals" "$goals_count"
    print_stat "Current Run" "$current_run"

    print_section "Recent Activity"
    printf "  Last Event: ${CYAN}%s${NC}\n" "$last_event"

    # Health indicator
    print_section "System Health"
    local health_color="$GREEN"
    local health_status="HEALTHY"

    if [ "$blocked_count" -gt "$((active_count / 3))" ]; then
        health_color="$YELLOW"
        health_status="WARNING (Many blocked tasks)"
    fi

    if [ "$in_progress_count" -gt 10 ]; then
        health_color="$YELLOW"
        health_status="WARNING (Many in-progress tasks)"
    fi

    printf "  Status: ${health_color}${BOLD}%s${NC}\n" "$health_status"

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    printf "  Run '${CYAN}bb5 status tasks${NC}' for detailed task stats\n"
    printf "  Run '${CYAN}bb5 status queue${NC}' for queue health\n"
    printf "  Run '${CYAN}bb5 status goals${NC}' for goal progress\n"
    echo "═══════════════════════════════════════════════════════════════"
}

# Task statistics display
show_task_stats() {
    print_header "Task Statistics"

    local active_count=0
    local completed_count=0

    if [ -d "$TASKS_DIR" ]; then
        active_count=$(find "$TASKS_DIR" -maxdepth 1 -type d | grep -v "^$TASKS_DIR$" | wc -l)
    fi

    if [ -d "$COMPLETED_TASKS_DIR" ]; then
        completed_count=$(find "$COMPLETED_TASKS_DIR" -maxdepth 1 -type d 2>/dev/null | grep -v "^$COMPLETED_TASKS_DIR$" | wc -l)
    fi

    local total_count=$((active_count + completed_count))

    local pending_count=$(count_tasks_by_status "pending")
    local in_progress_count=$(count_tasks_by_status "in_progress")
    local blocked_count=$(count_tasks_by_status "blocked")
    local done_count=$(count_tasks_by_status "completed")

    local critical_count=$(count_tasks_by_priority "critical")
    local high_count=$(count_tasks_by_priority "high")
    local medium_count=$(count_tasks_by_priority "medium")
    local low_count=$(count_tasks_by_priority "low")

    print_section "Overview"
    print_stat "Total Tasks" "$total_count"
    print_stat "Active" "$active_count"
    print_stat "Completed" "$completed_count"

    print_section "By Status"
    printf "  Pending:      ${BOLD}%d${NC}  " "$pending_count"
    print_bar "$pending_count" "$active_count" 25 "$BLUE"

    printf "  In Progress:  ${BOLD}%d${NC}  " "$in_progress_count"
    print_bar "$in_progress_count" "$active_count" 25 "$YELLOW"

    printf "  Blocked:      ${BOLD}%d${NC}  " "$blocked_count"
    print_bar "$blocked_count" "$active_count" 25 "$RED"

    printf "  Completed:    ${BOLD}%d${NC}  " "$done_count"
    print_bar "$done_count" "$total_count" 25 "$GREEN"

    print_section "By Priority (Active Tasks)"
    printf "  ${RED}CRITICAL${NC}: ${BOLD}%d${NC}\n" "$critical_count"
    printf "  ${YELLOW}HIGH${NC}:     ${BOLD}%d${NC}\n" "$high_count"
    printf "  ${CYAN}MEDIUM${NC}:   ${BOLD}%d${NC}\n" "$medium_count"
    printf "  ${BLUE}LOW${NC}:      ${BOLD}%d${NC}\n" "$low_count"

    # Queue-based stats if available
    if [ -f "$QUEUE_FILE" ]; then
        print_section "Queue Metadata"
        local q_total=$(get_queue_stat "total_tasks")
        local q_completed=$(get_queue_stat "completed")
        local q_in_progress=$(get_queue_stat "in_progress")
        local q_pending=$(get_queue_stat "pending")

        print_stat "Total (Queue)" "$q_total"
        print_stat "Completed" "$q_completed"
        print_stat "In Progress" "$q_in_progress"
        print_stat "Pending" "$q_pending"

        local ready=$(grep "ready_to_execute:" "$QUEUE_FILE" 2>/dev/null | sed 's/.*:[[:space:]]*//')
        local blocked_q=$(grep "blocked_count:" "$QUEUE_FILE" 2>/dev/null | sed 's/.*:[[:space:]]*//')

        if [ -n "$ready" ]; then
            print_stat "Ready to Execute" "$ready"
        fi

        if [ -n "$blocked_q" ]; then
            print_stat "Blocked by Deps" "$blocked_q"
        fi
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
}

# Queue health display
show_queue_health() {
    print_header "Queue Health Status"

    local health=$(check_queue_health)

    print_section "Queue File Status"
    case "$health" in
        healthy)
            printf "  Status: ${GREEN}${BOLD}✓ HEALTHY${NC}\n"
            printf "  File:   ${CYAN}%s${NC}\n" "$QUEUE_FILE"
            ;;
        corrupted)
            printf "  Status: ${RED}${BOLD}✗ CORRUPTED${NC}\n"
            printf "  File:   ${CYAN}%s${NC}\n" "$QUEUE_FILE"
            printf "\n  ${YELLOW}Warning: Queue file has parse errors${NC}\n"
            ;;
        missing)
            printf "  Status: ${YELLOW}${BOLD}⚠ MISSING${NC}\n"
            printf "  File:   ${CYAN}%s${NC}\n" "$QUEUE_FILE"
            ;;
    esac

    if [ "$health" = "healthy" ] && [ -f "$QUEUE_FILE" ]; then
        print_section "Queue Statistics"

        local total=$(get_queue_stat "total_tasks")
        local completed=$(get_queue_stat "completed")
        local in_progress=$(get_queue_stat "in_progress")
        local pending=$(get_queue_stat "pending")

        print_stat "Total Tasks" "$total"
        print_stat "Completed" "$completed"
        print_stat "In Progress" "$in_progress"
        print_stat "Pending" "$pending"

        # Calculate percentages
        if [ -n "$total" ] && [ "$total" -gt 0 ]; then
            local completion_rate=$((completed * 100 / total))
            print_stat "Completion Rate" "${completion_rate}%"
        fi

        # Get blocked and ready counts
        local blocked=$(grep "blocked_count:" "$QUEUE_FILE" 2>/dev/null | sed 's/.*:[[:space:]]*//')
        local ready=$(grep "ready_to_execute:" "$QUEUE_FILE" 2>/dev/null | sed 's/.*:[[:space:]]*//')

        print_section "Execution Status"
        if [ -n "$ready" ]; then
            printf "  Ready to Execute: ${GREEN}${BOLD}%s${NC}\n" "$ready"
        fi

        if [ -n "$blocked" ]; then
            printf "  Blocked by Deps:  ${YELLOW}${BOLD}%s${NC}\n" "$blocked"
        fi

        # Show priority distribution
        print_section "Priority Distribution"
        local critical=$(grep "priority:[[:space:]]*CRITICAL" "$QUEUE_FILE" 2>/dev/null | wc -l | tr -d ' ')
        local high=$(grep "priority:[[:space:]]*HIGH" "$QUEUE_FILE" 2>/dev/null | wc -l | tr -d ' ')
        local medium=$(grep "priority:[[:space:]]*MEDIUM" "$QUEUE_FILE" 2>/dev/null | wc -l | tr -d ' ')
        local low=$(grep "priority:[[:space:]]*LOW" "$QUEUE_FILE" 2>/dev/null | wc -l | tr -d ' ')

        printf "  ${RED}CRITICAL${NC}: ${BOLD}%d${NC}\n" "$critical"
        printf "  ${YELLOW}HIGH${NC}:     ${BOLD}%d${NC}\n" "$high"
        printf "  ${CYAN}MEDIUM${NC}:   ${BOLD}%d${NC}\n" "$medium"
        printf "  ${BLUE}LOW${NC}:      ${BOLD}%d${NC}\n" "$low"

        # Show quick wins
        print_section "Quick Wins (High Score, Low Effort)"
        grep -A 1 "quick_wins:" "$QUEUE_FILE" 2>/dev/null | tail -n +2 | head -5 | while read -r line; do
            local task_id=$(echo "$line" | grep -oE 'TASK-[A-Z0-9-]+' | head -1)
            if [ -n "$task_id" ]; then
                printf "  • ${CYAN}%s${NC}\n" "$task_id"
            fi
        done

        # Orphaned tasks check (claimed but no recent activity)
        print_section "Orphaned Tasks Check"
        local orphaned=0

        if [ -d "$TASKS_DIR" ]; then
            for task_dir in "$TASKS_DIR"/*/; do
                if [ -d "$task_dir" ]; then
                    local task_file="$task_dir/task.md"
                    if [ -f "$task_file" ]; then
                        local status=$(grep -i "^\s*status:" "$task_file" 2>/dev/null | head -1 | sed 's/.*status:[[:space:]]*//' | sed 's/\*//g' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
                        local owner=$(grep -i "^\s*owner:" "$task_file" 2>/dev/null | head -1 | sed 's/.*owner:[[:space:]]*//' | sed 's/\*//g' | tr -d '[:space:]')

                        if [ "$status" = "in_progress" ] && [ -n "$owner" ]; then
                            # Check for recent activity (THOUGHTS.md modified in last 24 hours)
                            local thoughts_file="$task_dir/THOUGHTS.md"
                            if [ -f "$thoughts_file" ]; then
                                local last_modified=$(stat -f "%m" "$thoughts_file" 2>/dev/null || stat -c "%Y" "$thoughts_file" 2>/dev/null || echo "0")
                                local now=$(date +%s)
                                local age_hours=$(((now - last_modified) / 3600))

                                if [ "$age_hours" -gt 24 ]; then
                                    ((orphaned++))
                                    local task_id=$(basename "$task_dir")
                                    printf "  ⚠ ${YELLOW}%s${NC} - %dh stale\n" "$task_id" "$age_hours"
                                fi
                            fi
                        fi
                    fi
                fi
            done
        fi

        if [ "$orphaned" -eq 0 ]; then
            printf "  ${GREEN}✓ No orphaned tasks detected${NC}\n"
        fi
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
}

# Goals progress display
show_goals() {
    print_header "Goal Progress Overview"

    local total_goals=$(count_active_goals)

    print_section "Summary"
    print_stat "Active Goals" "$total_goals"

    if [ "$total_goals" -eq 0 ]; then
        printf "\n  ${YELLOW}No active goals found${NC}\n"
        return
    fi

    # Count by progress ranges
    local not_started=$(count_goals_by_progress 0 1)
    local in_progress_25=$(count_goals_by_progress 1 25)
    local in_progress_50=$(count_goals_by_progress 25 50)
    local in_progress_75=$(count_goals_by_progress 50 75)
    local near_complete=$(count_goals_by_progress 75 99)
    local complete=$(count_goals_by_progress 99 101)

    print_section "Progress Distribution"
    printf "  Not Started (0%%):     ${BOLD}%d${NC}\n" "$not_started"

    printf "  1-25%%:                  ${BOLD}%d${NC}  " "$in_progress_25"
    print_bar "$in_progress_25" "$total_goals" 20 "$RED"

    printf "  25-50%%:                 ${BOLD}%d${NC}  " "$in_progress_50"
    print_bar "$in_progress_50" "$total_goals" 20 "$YELLOW"

    printf "  50-75%%:                 ${BOLD}%d${NC}  " "$in_progress_75"
    print_bar "$in_progress_75" "$total_goals" 20 "$BLUE"

    printf "  75-99%%:                 ${BOLD}%d${NC}  " "$near_complete"
    print_bar "$near_complete" "$total_goals" 20 "$CYAN"

    printf "  Complete (100%%):       ${BOLD}%d${NC}  " "$complete"
    print_bar "$complete" "$total_goals" 20 "$GREEN"

    # List goals with progress
    print_section "Active Goals"

    if [ -d "$GOALS_DIR" ]; then
        for goal_file in "$GOALS_DIR"/*/goal.yaml; do
            if [ -f "$goal_file" ]; then
                local goal_id=$(grep "^goal_id:" "$goal_file" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//')
                local goal_name=$(grep "^name:" "$goal_file" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//' | sed 's/^"//;s/"$//' | cut -c1-40)
                local progress=$(grep -E "^\s+percentage:" "$goal_file" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//')
                local status=$(grep "^\s*status:" "$goal_file" 2>/dev/null | head -1 | sed 's/.*:[[:space:]]*//')

                if [ -n "$goal_id" ]; then
                    local color="$NC"
                    if [ -n "$progress" ]; then
                        if [ "$progress" -eq 100 ]; then
                            color="$GREEN"
                        elif [ "$progress" -ge 75 ]; then
                            color="$CYAN"
                        elif [ "$progress" -ge 50 ]; then
                            color="$BLUE"
                        elif [ "$progress" -ge 25 ]; then
                            color="$YELLOW"
                        else
                            color="$RED"
                        fi
                    fi

                    printf "  ${CYAN}%s${NC} - %s\n" "$goal_id" "$goal_name"
                    printf "    Progress: ${color}${BOLD}%s%%${NC} | Status: %s\n" "${progress:-0}" "${status:-unknown}"
                fi
            fi
        done
    fi

    # Recently completed goals from timeline
    print_section "Recently Completed"
    if [ -f "$TIMELINE_FILE" ]; then
        grep -B 2 -A 3 "status:\s*completed" "$TIMELINE_FILE" 2>/dev/null | grep "name:" | head -3 | while read -r line; do
            local name=$(echo "$line" | sed 's/.*name:[[:space:]]*//' | sed 's/^"//;s/"$//' | cut -c1-50)
            printf "  ✓ %s\n" "$name"
        done
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════════"
}

# Handle commands
case "$COMMAND" in
    overview|status)
        show_overview
        ;;
    tasks|task)
        show_task_stats
        ;;
    queue)
        show_queue_health
        ;;
    goals|goal)
        show_goals
        ;;
    *)
        echo "Unknown command: $COMMAND"
        echo "Usage: bb5 status [overview|tasks|queue|goals]"
        exit 1
        ;;
esac
