#!/bin/bash
#
# RALF-Executor
# Purpose: Execute tasks from queue, commit code, report status
# Runs: Continuously in background
#

set -euo pipefail

# Configuration
PROJECT_DIR="${RALF_PROJECT_DIR:-$HOME/.blackbox5/5-project-memory/blackbox5}"
COMM_DIR="$PROJECT_DIR/.autonomous/communications"
QUEUE_FILE="$COMM_DIR/queue.yaml"
EVENTS_FILE="$COMM_DIR/events.yaml"
CHAT_FILE="$COMM_DIR/chat-log.yaml"
HEARTBEAT_FILE="$COMM_DIR/heartbeat.yaml"
STATE_FILE="$PROJECT_DIR/STATE.yaml"
RUNS_DIR="$PROJECT_DIR/runs/executor"

LOOP_INTERVAL=30
IDLE_TIMEOUT=300  # 5 minutes

# State
current_task=""
idle_start=""
run_counter=0

# Logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [EXECUTOR] $*"
}

# Update heartbeat
update_heartbeat() {
    local status="$1"
    local action="${2:-idle}"
    local tmp_file=$(mktemp)

    cat > "$tmp_file" << EOF
heartbeats:
  planner:
    last_seen: $(yq '.heartbeats.planner.last_seen' "$HEARTBEAT_FILE" 2>/dev/null || echo "null")
    status: $(yq '.heartbeats.planner.status' "$HEARTBEAT_FILE" 2>/dev/null || echo "unknown")
    current_action: $(yq '.heartbeats.planner.current_action' "$HEARTBEAT_FILE" 2>/dev/null || echo "null")

  executor:
    last_seen: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    status: $status
    current_action: $action

metadata:
  timeout_seconds: 120
  last_updated: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
EOF

    mv "$tmp_file" "$HEARTBEAT_FILE"
}

# Add event
add_event() {
    local type="$1"
    local task_id="${2:-}"
    local data="${3:-}"

    local tmp_file=$(mktemp)
    local last_id
    last_id=$(yq '.metadata.last_event_id' "$EVENTS_FILE" 2>/dev/null || echo "0")
    local new_id=$((last_id + 1))

    # Read current events
    local current_events
    current_events=$(yq '.events' "$EVENTS_FILE" 2>/dev/null || echo "[]")

    # Create new event
    local new_event
    new_event=$(cat << EOF
{
  "id": $new_id,
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "type": "$type",
  "task_id": ${task_id:+"$task_id"},
  "data": ${data:-null}
}
EOF
)

    # Write combined (keep only last 100 events)
    yq -n "
events: ($current_events + [$new_event]) | .[-100:]
metadata:
  last_event_id: $new_id
  last_updated: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
" > "$tmp_file"

    mv "$tmp_file" "$EVENTS_FILE"
}

# Get next task from queue
get_next_task() {
    yq '.queue | .[0] | select(.status == "pending")' "$QUEUE_FILE" 2>/dev/null
}

# Claim task (mark as in_progress)
claim_task() {
    local task_id="$1"
    local tmp_file=$(mktemp)

    yq "
.queue = [.queue[] | select(.id == \"$task_id\") .status = \"in_progress\"] | [.queue[] | select(.id != \"$task_id\")] + [.queue[] | select(.id == \"$task_id\")]
" "$QUEUE_FILE" > "$tmp_file"

    mv "$tmp_file" "$QUEUE_FILE"
    log "Claimed task $task_id"
}

# Remove completed task from queue
complete_task_in_queue() {
    local task_id="$1"
    local tmp_file=$(mktemp)

    local current_depth
    current_depth=$(yq '.queue | length' "$QUEUE_FILE")

    yq "
.queue = [.queue[] | select(.id != \"$task_id\")]
metadata:
  last_updated: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
  updated_by: executor
  queue_depth_target: 5
  current_depth: $((current_depth - 1))
" "$QUEUE_FILE" > "$tmp_file"

    mv "$tmp_file" "$QUEUE_FILE"
}

# Mark task complete in STATE.yaml
mark_task_complete() {
    local task_id="$1"
    local commit_hash="${2:-}"
    local result="${3:-success}"

    # TODO: Implement STATE.yaml update
    # Move task from active to completed
    # Record commit_hash, timestamp, result
    log "Marked $task_id as complete in STATE.yaml (placeholder)"
}

# Execute task
execute_task() {
    local task_json="$1"
    local task_id
    local task_type
    local title
    local approach

    task_id=$(echo "$task_json" | yq '.id')
    task_type=$(echo "$task_json" | yq '.type')
    title=$(echo "$task_json" | yq '.title')
    approach=$(echo "$task_json" | yq '.approach')

    log "Executing task: $task_id - $title"
    log "Type: $task_type"
    log "Approach: $approach"

    # Create run folder
    run_counter=$((run_counter + 1))
    local run_dir="$RUNS_DIR/run-$(printf %04d $run_counter)"
    mkdir -p "$run_dir"

    # Write THOUGHTS.md header
    cat > "$run_dir/THOUGHTS.md" << EOF
# THOUGHTS: Executor Run $run_counter

**Task:** $task_id - $title
**Started:** $(date)
**Type:** $task_type

## Approach
$approach

## Execution Log

EOF

    # TODO: Implement actual task execution
    # - Use skills based on task_type
    # - Execute approach
    # - Document progress
    # - Handle errors

    # Simulate execution for now
    log "Simulating execution..."
    sleep 2

    # Write completion
    echo -e "\n## Completed\n\nTask completed successfully." >> "$run_dir/THOUGHTS.md"

    echo "$run_dir"
}

# Commit changes
commit_changes() {
    local task_id="$1"
    local run_dir="$2"

    # TODO: Implement actual git commit using git-commit skill
    # For now, simulate
    local commit_hash="simulated-$(date +%s)"

    log "Committed changes: $commit_hash"
    echo "$commit_hash"
}

# Ask question via chat
ask_question() {
    local task_id="$1"
    local question="$2"

    local tmp_file=$(mktemp)
    local last_id
    last_id=$(yq '.metadata.last_message_id' "$CHAT_FILE" 2>/dev/null || echo "0")
    local new_id=$((last_id + 1))

    local current_messages
    current_messages=$(yq '.messages' "$CHAT_FILE" 2>/dev/null || echo "[]")

    local new_message
    new_message=$(cat << EOF
{
  "id": $new_id,
  "from": "executor",
  "to": "planner",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "type": "question",
  "task_id": "$task_id",
  "content": "$question"
}
EOF
)

    yq -n "
messages: ($current_messages + [$new_message]) | .[-50:]
metadata:
  last_message_id: $new_id
  last_updated: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
" > "$tmp_file"

    mv "$tmp_file" "$CHAT_FILE"
    log "Asked question about $task_id"
}

# Main loop
main() {
    log "RALF-Executor starting..."
    log "Project: $PROJECT_DIR"
    log "Runs directory: $RUNS_DIR"

    # Initialize
    mkdir -p "$RUNS_DIR"
    update_heartbeat "starting" "initializing"

    while true; do
        update_heartbeat "running" "checking_queue"

        # Check for task
        local task
        task=$(get_next_task)

        if [[ -n "$task" && "$task" != "null" ]]; then
            # Found task, reset idle timer
            idle_start=""

            local task_id
            task_id=$(echo "$task" | yq '.id')

            # Claim it
            claim_task "$task_id"
            current_task="$task_id"

            # Report started
            add_event "started" "$task_id"
            update_heartbeat "running" "executing_$task_id"

            # Execute
            local run_dir
            run_dir=$(execute_task "$task")

            # Commit
            local commit_hash
            commit_hash=$(commit_changes "$task_id" "$run_dir")

            # Mark complete in queue and STATE
            complete_task_in_queue "$task_id"
            mark_task_complete "$task_id" "$commit_hash" "success"

            # Report completed
            add_event "completed" "$task_id" "{\"commit_hash\": \"$commit_hash\"}"

            current_task=""
            log "Task $task_id complete"

        else
            # No task available
            if [[ -z "$idle_start" ]]; then
                idle_start=$(date +%s)
                add_event "idle"
            fi

            local idle_time
            idle_time=$(($(date +%s) - idle_start))

            log "No tasks available, idle for ${idle_time}s"
            update_heartbeat "idle" "waiting_for_tasks"

            # Check timeout
            if [[ "$idle_time" -gt "$IDLE_TIMEOUT" ]]; then
                log "Idle timeout reached, exiting"
                add_event "idle_timeout"
                break
            fi
        fi

        # Sleep before next check
        sleep "$LOOP_INTERVAL"
    done

    log "Executor shutting down"
    update_heartbeat "stopped" "shutdown"
}

# Handle shutdown
cleanup() {
    log "Shutting down..."
    if [[ -n "$current_task" ]]; then
        add_event "interrupted" "$current_task"
    fi
    update_heartbeat "stopped" "shutdown"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Run
main "$@"
