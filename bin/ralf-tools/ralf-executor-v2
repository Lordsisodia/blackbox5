#!/bin/bash
#
# RALF-Executor v2
# Purpose: Task execution agent using v2-legacy-based.md prompt
# Runs: Continuously in background, invokes Claude Code
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Auto-detect if running in GitHub Codespace
if [[ -n "${CODESPACE_NAME:-}" ]] || [[ -d "/workspaces/blackbox5" ]]; then
    # GitHub Codespace environment
    BASE_DIR="/workspaces/blackbox5"
    # Set up API key for Claude if available
    if [[ -f "$HOME/.anthropic_api_key" ]]; then
        export ANTHROPIC_API_KEY=$(cat "$HOME/.anthropic_api_key")
    fi
    # Set base URL if using proxy (e.g., api.z.ai)
    if [[ -n "${ANTHROPIC_BASE_URL:-}" ]]; then
        export ANTHROPIC_BASE_URL
    elif [[ -f "$HOME/.anthropic_base_url" ]]; then
        export ANTHROPIC_BASE_URL=$(cat "$HOME/.anthropic_base_url")
    fi
else
    # Local environment
    BASE_DIR="${RALF_BASE_DIR:-$HOME/.blackbox5}"
fi

PROJECT_DIR="${RALF_PROJECT_DIR:-$BASE_DIR/5-project-memory/blackbox5}"
ENGINE_DIR="${RALF_ENGINE_DIR:-$BASE_DIR/2-engine}"
PROMPT_FILE="$ENGINE_DIR/instructions/executor/versions/v4-20260202/executor.md"
COMM_DIR="$PROJECT_DIR/.autonomous/communications"
RUNS_DIR="$PROJECT_DIR/runs/executor"

# Logging
LOG_FILE="$PROJECT_DIR/.autonomous/executor-v2.log"

# Initialize run counter from highest existing run (for persistence across restarts)
init_run_counter() {
    local highest=0
    if [[ -d "$RUNS_DIR" ]]; then
        # Use sed to remove leading zeros to avoid octal interpretation
        highest=$(ls -1 "$RUNS_DIR" 2>/dev/null | grep -E '^run-[0-9]+$' | sed 's/run-//' | sed 's/^0*//' | sort -n | tail -1 || echo "0")
        # Handle case where all runs are 0000
        [[ -z "$highest" ]] && highest=0
    fi
    echo "$highest"
}
RUN_COUNTER=$(init_run_counter)

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

log() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} âš¡ ${GREEN}EXECUTOR${NC} $*" | tee -a "$LOG_FILE"
}

error() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} âŒ ${RED}EXECUTOR ERROR${NC} $*" | tee -a "$LOG_FILE" >&2
}

info() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} â„¹ï¸  ${YELLOW}INFO${NC} $*" | tee -a "$LOG_FILE"
}

success() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} âœ… ${GREEN}SUCCESS${NC} $*" | tee -a "$LOG_FILE"
}

# Spinner animation
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ -d /proc/$pid ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Initialize run directory and tracking
init_run() {
    RUN_COUNTER=$((RUN_COUNTER + 1))
    local run_dir="$RUNS_DIR/run-$(printf %04d $RUN_COUNTER)"
    mkdir -p "$run_dir"
    export RALF_RUN_DIR="$run_dir"
    export RALF_LOOP_NUMBER="$RUN_COUNTER"

    # Create metadata.yaml file for tracking (co-located with run)
    local now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$run_dir/metadata.yaml" << EOF
loop:
  number: $RUN_COUNTER
  agent: executor
  timestamp_start: "$now"
  timestamp_end: null
  duration_seconds: null

state:
  task_claimed: null
  task_status: "pending"  # pending, in_progress, completed, failed
  files_modified: []
  commit_hash: null

actions_taken: []
discoveries: []
questions_asked: []
next_steps: []
blockers: []

notes: "Loop initialized, awaiting completion..."
EOF

    # Append to daily timeline (shared across agents)
    local today=$(date -u +%Y-%m-%d)
    local timeline_file="$PROJECT_DIR/runs/timeline/$today.md"
    if [[ ! -f "$timeline_file" ]]; then
        echo "# Timeline - $today" > "$timeline_file"
        echo "" >> "$timeline_file"
        echo "## Agent Activity" >> "$timeline_file"
        echo "" >> "$timeline_file"
    fi

    echo "- **$(date -u +%H:%M:%S)** - Executor Loop $RUN_COUNTER started" >> "$timeline_file"

    echo "$run_dir"
}

# Read current state for context
read_state() {
    local queue="{}"
    local events="{}"
    local heartbeat="{}"
    local chat="{}"

    if [[ -f "$COMM_DIR/queue.yaml" ]]; then
        queue=$(cat "$COMM_DIR/queue.yaml" 2>/dev/null || echo "{}")
    fi

    if [[ -f "$COMM_DIR/events.yaml" ]]; then
        events=$(cat "$COMM_DIR/events.yaml" 2>/dev/null | tail -20 || echo "{}")
    fi

    if [[ -f "$COMM_DIR/heartbeat.yaml" ]]; then
        heartbeat=$(cat "$COMM_DIR/heartbeat.yaml" 2>/dev/null || echo "{}")
    fi

    if [[ -f "$COMM_DIR/chat-log.yaml" ]]; then
        chat=$(cat "$COMM_DIR/chat-log.yaml" 2>/dev/null | tail -20 || echo "{}")
    fi

    echo "QUEUE: $queue"
    echo "EVENTS: $events"
    echo "HEARTBEAT: $heartbeat"
    echo "CHAT: $chat"
}

# Update heartbeat
update_heartbeat() {
    local status="$1"
    local action="${2:-idle}"

    python3 << PYEOF
import yaml
from datetime import datetime, timezone

heartbeat_file = "$COMM_DIR/heartbeat.yaml"

try:
    with open(heartbeat_file, 'r') as f:
        data = yaml.safe_load(f) or {}
except FileNotFoundError:
    data = {}

if not isinstance(data, dict):
    data = {}
if "heartbeats" not in data:
    data["heartbeats"] = {}
if "executor" not in data["heartbeats"]:
    data["heartbeats"]["executor"] = {}

now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

data["heartbeats"]["executor"]["last_seen"] = now
data["heartbeats"]["executor"]["status"] = "$status"
data["heartbeats"]["executor"]["current_action"] = "$action"

with open(heartbeat_file, 'w') as f:
    yaml.dump(data, f, default_flow_style=False, sort_keys=False)
PYEOF
}

# Main execution - invoke Claude
run_claude() {
    local run_dir="$1"
    local state_context
    state_context=$(read_state)

    log "Invoking Claude Code for execution..."

    # Build the full prompt
    local full_prompt
    full_prompt=$(cat << EOF
$(cat "$PROMPT_FILE")

---

## CURRENT STATE

Run directory: $run_dir

State Context:
$state_context

Project Directory: $PROJECT_DIR
Engine Directory: $ENGINE_DIR

## YOUR TASK

Execute ONE execution iteration:
1. Check tasks/active/ for pending tasks
2. If task available: Claim it, execute it, document it, commit it, move to completed/
3. If no tasks: Find work - check feedback/, analyze runs/, organize insights/
4. Write your THOUGHTS.md, RESULTS.md, DECISIONS.md to the run directory
5. Update metadata.yaml in your run directory with loop results
6. Update events.yaml and heartbeat.yaml
7. Signal completion (COMPLETE, RETRY, BLOCKED, FAILED, or PARTIAL)

Do not loop - this is one iteration. The bash script will handle the loop.
EOF
)

    # Log prompt size
    info "ğŸ“ Prompt size: ${#full_prompt} chars"

    # Invoke Claude Code
    echo "$full_prompt" | claude -p \
        --dangerously-skip-permissions \
        --allowed-tools "Read,Edit,Bash,Write" \
        2>&1 >> "$LOG_FILE"
}

# Main loop
main() {
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC} âš¡ ${GREEN}RALF-Executor v2${NC} - Task Execution Agent                ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    log "ğŸš€ Starting up..."
    info "ğŸ“ Project: ${PROJECT_DIR#$HOME/}"
    info "ğŸ“ Prompt: ${PROMPT_FILE#$HOME/}"

    # Check prompt file exists
    if [[ ! -f "$PROMPT_FILE" ]]; then
        error "Prompt file not found: $PROMPT_FILE"
        exit 1
    fi

    # Create directories
    mkdir -p "$RUNS_DIR"
    mkdir -p "$COMM_DIR"
    mkdir -p "$PROJECT_DIR/runs/timeline"
    mkdir -p "$PROJECT_DIR/runs/assets"

    success "âœ¨ Ready for iterations"
    echo ""

    while true; do
        RUN_COUNTER=$((RUN_COUNTER + 1))
        echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        log "ğŸ”„ Iteration #${RUN_COUNTER}"
        echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"

        # Initialize run
        local run_dir
        run_dir=$(init_run)
        info "ğŸ“‚ Run: ${run_dir#$PROJECT_DIR/}"

        # Update heartbeat
        update_heartbeat "running" "executing"

        # Run Claude with spinner
        info "ğŸ¤– Invoking Claude Code..."
        run_claude "$run_dir" &
        local claude_pid=$!
        spinner $claude_pid
        wait $claude_pid
        local claude_exit=$?

        if [[ $claude_exit -eq 0 ]]; then
            success "âœ… Claude completed successfully"
        else
            error "âŒ Claude exited with code $claude_exit"
        fi

        # Update heartbeat
        update_heartbeat "running" "sleeping"

        echo ""
        info "ğŸ˜´ Sleeping for 3 seconds..."
        echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo ""
        sleep 3
    done
}

# Handle shutdown
cleanup() {
    log "Shutting down..."
    update_heartbeat "stopped" "shutdown"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Run
main "$@"
