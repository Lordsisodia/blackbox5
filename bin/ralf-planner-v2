#!/bin/bash
#
# RALF-Planner v2
# Purpose: Strategic planning agent using v2-legacy-based.md prompt
# Runs: Continuously in background, invokes Claude Code
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Auto-detect if running in GitHub Codespace
if [[ -n "${CODESPACE_NAME:-}" ]] || [[ -d "/workspaces/blackbox5" ]]; then
    # GitHub Codespace environment
    BASE_DIR="/workspaces/blackbox5"
    # Set up API key for Claude if available
    if [[ -f "$HOME/.anthropic_api_key" ]]; then
        export ANTHROPIC_API_KEY=$(cat "$HOME/.anthropic_api_key")
    fi
    # Set base URL if using proxy (e.g., api.z.ai)
    if [[ -n "${ANTHROPIC_BASE_URL:-}" ]]; then
        export ANTHROPIC_BASE_URL
    elif [[ -f "$HOME/.anthropic_base_url" ]]; then
        export ANTHROPIC_BASE_URL=$(cat "$HOME/.anthropic_base_url")
    fi
else
    # Local environment
    BASE_DIR="${RALF_BASE_DIR:-$HOME/.blackbox5}"
fi

PROJECT_DIR="${RALF_PROJECT_DIR:-$BASE_DIR/5-project-memory/blackbox5}"
ENGINE_DIR="${RALF_ENGINE_DIR:-$BASE_DIR/2-engine/.autonomous}"
PROMPT_FILE="$ENGINE_DIR/prompts/system/planner/variations/v2-legacy-based.md"
COMM_DIR="$PROJECT_DIR/.autonomous/communications"
RUNS_DIR="$PROJECT_DIR/runs/planner"

# Logging
LOG_FILE="$PROJECT_DIR/.autonomous/planner-v2.log"
RUN_COUNTER=0

# Colors
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

log() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} ğŸ§  ${BLUE}PLANNER${NC} $*" | tee -a "$LOG_FILE"
}

error() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} âŒ ${RED}PLANNER ERROR${NC} $*" | tee -a "$LOG_FILE" >&2
}

info() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} â„¹ï¸  ${YELLOW}INFO${NC} $*" | tee -a "$LOG_FILE"
}

success() {
    local timestamp=$(date '+%H:%M:%S')
    echo -e "${CYAN}[$timestamp]${NC} âœ… ${GREEN}SUCCESS${NC} $*" | tee -a "$LOG_FILE"
}

# Initialize run directory and tracking
init_run() {
    RUN_COUNTER=$((RUN_COUNTER + 1))
    local run_dir="$RUNS_DIR/run-$(printf %04d $RUN_COUNTER)"
    mkdir -p "$run_dir"
    export RALF_RUN_DIR="$run_dir"
    export RALF_LOOP_NUMBER="$RUN_COUNTER"

    # Create metadata.yaml file for tracking (co-located with run)
    local now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$run_dir/metadata.yaml" << EOF
loop:
  number: $RUN_COUNTER
  agent: planner
  timestamp_start: "$now"
  timestamp_end: null
  duration_seconds: null

state:
  active_tasks_count: 0
  completed_tasks_count: 0
  executor_status: "unknown"
  queue_depth: 0

actions_taken: []
discoveries: []
questions_answered: []
tasks_created: []
next_steps: []
blockers: []

notes: "Loop initialized, awaiting completion..."
EOF

    # Append to daily timeline (shared across agents)
    local today=$(date -u +%Y-%m-%d)
    local timeline_file="$PROJECT_DIR/runs/timeline/$today.md"
    if [[ ! -f "$timeline_file" ]]; then
        echo "# Timeline - $today" > "$timeline_file"
        echo "" >> "$timeline_file"
        echo "## Agent Activity" >> "$timeline_file"
        echo "" >> "$timeline_file"
    fi

    echo "- **$(date -u +%H:%M:%S)** - Planner Loop $RUN_COUNTER started" >> "$timeline_file"

    echo "$run_dir"
}

# Read current state for context
read_state() {
    local queue="{}"
    local events="{}"
    local heartbeat="{}"

    if [[ -f "$COMM_DIR/queue.yaml" ]]; then
        queue=$(cat "$COMM_DIR/queue.yaml" 2>/dev/null || echo "{}")
    fi

    if [[ -f "$COMM_DIR/events.yaml" ]]; then
        events=$(cat "$COMM_DIR/events.yaml" 2>/dev/null | tail -50 || echo "{}")
    fi

    if [[ -f "$COMM_DIR/heartbeat.yaml" ]]; then
        heartbeat=$(cat "$COMM_DIR/heartbeat.yaml" 2>/dev/null || echo "{}")
    fi

    echo "QUEUE: $queue"
    echo "EVENTS: $events"
    echo "HEARTBEAT: $heartbeat"
}

# Update heartbeat
update_heartbeat() {
    local status="$1"
    local action="${2:-idle}"

    python3 << PYEOF
import yaml
from datetime import datetime, timezone

heartbeat_file = "$COMM_DIR/heartbeat.yaml"

try:
    with open(heartbeat_file, 'r') as f:
        data = yaml.safe_load(f) or {}
except FileNotFoundError:
    data = {}

if not isinstance(data, dict):
    data = {}
if "heartbeats" not in data:
    data["heartbeats"] = {}
if "planner" not in data["heartbeats"]:
    data["heartbeats"]["planner"] = {}

now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

data["heartbeats"]["planner"]["last_seen"] = now
data["heartbeats"]["planner"]["status"] = "$status"
data["heartbeats"]["planner"]["current_action"] = "$action"

with open(heartbeat_file, 'w') as f:
    yaml.dump(data, f, default_flow_style=False, sort_keys=False)
PYEOF
}

# Main execution - invoke Claude
run_claude() {
    local run_dir="$1"
    local state_context
    state_context=$(read_state)

    log "Invoking Claude Code for planning..."

    # Build the full prompt
    local full_prompt
    full_prompt=$(cat << EOF
$(cat "$PROMPT_FILE")

---

## CURRENT STATE

Run directory: $run_dir

State Context:
$state_context

Project Directory: $PROJECT_DIR
Engine Directory: $ENGINE_DIR

## YOUR TASK

Execute ONE planning iteration:
1. Read the current state from communications files
2. Decide what action to take (plan tasks, answer questions, analyze, or review)
3. Update queue.yaml, chat-log.yaml, or knowledge/analysis/ as needed
4. Write your THOUGHTS.md, RESULTS.md, DECISIONS.md to the run directory
5. Update metadata.yaml in your run directory with loop results
6. Update heartbeat.yaml
7. Signal completion

Do not loop - this is one iteration. The bash script will handle the loop.
EOF
)

    # Invoke Claude Code
    export RALF_RUN_DIR="$run_dir"
    export RALF_PROJECT_DIR="$PROJECT_DIR"
    export RALF_ENGINE_DIR="$ENGINE_DIR"

    # Log prompt size
    info "ğŸ“ Prompt size: ${#full_prompt} chars"

    # Invoke Claude Code
    echo "$full_prompt" | claude -p \
        --dangerously-skip-permissions \
        --allowed-tools "Read,Edit,Bash,Write" \
        2>&1 >> "$LOG_FILE"
}

# Spinner animation
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ -d /proc/$pid ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Main loop
main() {
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC} ğŸ§  ${CYAN}RALF-Planner v2${NC} - Strategic Planning Agent              ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    log "ğŸš€ Starting up..."
    info "ğŸ“ Project: ${PROJECT_DIR#$HOME/}"
    info "ğŸ“ Prompt: ${PROMPT_FILE#$HOME/}"

    # Check prompt file exists
    if [[ ! -f "$PROMPT_FILE" ]]; then
        error "Prompt file not found: $PROMPT_FILE"
        exit 1
    fi

    # Create directories
    mkdir -p "$RUNS_DIR"
    mkdir -p "$COMM_DIR"
    mkdir -p "$PROJECT_DIR/knowledge/analysis"
    mkdir -p "$PROJECT_DIR/runs/timeline"
    mkdir -p "$PROJECT_DIR/runs/assets"

    success "âœ¨ Ready for iterations"
    echo ""

    while true; do
        RUN_COUNTER=$((RUN_COUNTER + 1))
        echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        log "ğŸ”„ Iteration #${RUN_COUNTER}"
        echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"

        # Initialize run
        local run_dir
        run_dir=$(init_run)
        info "ğŸ“‚ Run: ${run_dir#$PROJECT_DIR/}"

        # Update heartbeat
        update_heartbeat "running" "planning"

        # Run Claude with spinner
        info "ğŸ¤– Invoking Claude Code..."
        run_claude "$run_dir" &
        local claude_pid=$!
        spinner $claude_pid
        wait $claude_pid
        local claude_exit=$?

        if [[ $claude_exit -eq 0 ]]; then
            success "âœ… Claude completed successfully"
        else
            error "âŒ Claude exited with code $claude_exit"
        fi

        # Update heartbeat
        update_heartbeat "running" "sleeping"

        echo ""
        info "ğŸ˜´ Sleeping for 3 seconds..."
        echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo ""
        sleep 3
    done
}

# Handle shutdown
cleanup() {
    log "Shutting down..."
    update_heartbeat "stopped" "shutdown"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Run
main "$@"
