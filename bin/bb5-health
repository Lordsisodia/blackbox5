#!/usr/bin/env python3
"""BB5 Health - CLI snapshot tool for system health monitoring.

Usage:
    bb5-health [options]
    bb5-health --format json
    bb5-health --queue --agents

Options:
    -f, --format FORMAT     Output format: table, json, csv (default: table)
    -q, --queue             Show queue stats only
    -a, --agents            Show agent stats only
    -s, --system            Show system health only
    -w, --watch SECONDS     Watch mode with refresh interval
    -h, --help              Show this help message

Examples:
    bb5-health                    # Full health snapshot
    bb5-health -f json            # JSON output
    bb5-health -q                 # Queue stats only
    bb5-health -w 5               # Refresh every 5 seconds
"""

import argparse
import csv
import json
import sys
import time
from datetime import datetime
from pathlib import Path

# Add lib to path
sys.path.insert(0, str(Path(__file__).parent / "lib"))

from health_monitor import (
    collect_queue,
    collect_heartbeat,
    collect_events,
    collect_metrics,
    calculate_health_score,
    calculate_queue_health,
    calculate_agent_health,
    calculate_throughput,
    calculate_commit_compliance,
    detect_stuck_tasks,
    init_database,
    save_snapshot,
    HealthSnapshot,
    get_health_color,
    get_health_emoji,
    format_duration,
)


def format_table(data: dict) -> str:
    """Format data as aligned table."""
    lines = []
    max_key = max(len(str(k)) for k in data.keys())
    for key, value in data.items():
        lines.append(f"  {key:<{max_key}} : {value}")
    return "\n".join(lines)


def get_health_snapshot() -> dict:
    """Collect and calculate health snapshot."""
    tasks = collect_queue()
    agents = collect_heartbeat()
    events = collect_events()
    metrics = collect_metrics()

    score, status, details = calculate_health_score(tasks, agents, events, metrics)
    queue_score, queue_status = calculate_queue_health(tasks)
    agent_score, agent_status = calculate_agent_health(agents)
    throughput = calculate_throughput(tasks)
    stuck = detect_stuck_tasks(tasks, events)
    compliance = calculate_commit_compliance(days=30, threshold=75.0)

    pending = sum(1 for t in tasks if t.status.value == "pending")
    in_progress = sum(1 for t in tasks if t.status.value == "in_progress")
    completed = sum(1 for t in tasks if t.status.value == "completed")
    blocked = sum(1 for t in tasks if t.status.value == "blocked")

    online = sum(1 for a in agents if a.is_online())
    stale = sum(1 for a in agents if a.is_stale())
    offline = len(agents) - online - stale

    return {
        "timestamp": datetime.now().isoformat(),
        "health_score": score,
        "status": status.value,
        "queue": {
            "pending": pending,
            "in_progress": in_progress,
            "completed": completed,
            "blocked": blocked,
            "total": len(tasks),
            "health_score": queue_score,
            "health_status": queue_status,
        },
        "agents": {
            "online": online,
            "stale": stale,
            "offline": offline,
            "total": len(agents),
            "health_score": agent_score,
            "health_status": agent_status,
        },
        "throughput": {
            "tasks_per_day": round(throughput, 2),
            "target": 5,
        },
        "compliance": compliance,
        "stuck_tasks": [
            {
                "id": st.task.id,
                "title": st.task.title,
                "reason": st.reason,
                "duration": st.stuck_duration,
            }
            for st in stuck
        ],
        "details": details,
    }


def output_table(data: dict, component: str = None) -> None:
    """Output data as formatted table."""
    emoji = get_health_emoji(data["health_score"])

    if component is None or component == "system":
        print(f"\n{emoji} BB5 Health Snapshot")
        print(f"{'=' * 50}")
        print(f"  Timestamp : {data['timestamp'][:19]}")
        print(f"  Score     : {data['health_score']}/100 ({data['status'].upper()})")
        print()

    if component is None or component == "queue":
        q = data["queue"]
        q_emoji = get_health_emoji(q["health_score"])
        print(f"{q_emoji} Queue Status")
        print("-" * 30)
        print(f"  Pending     : {q['pending']}")
        print(f"  In Progress : {q['in_progress']}")
        print(f"  Completed   : {q['completed']}")
        print(f"  Blocked     : {q['blocked']}")
        print(f"  Total       : {q['total']}")
        print(f"  Health      : {q['health_score']:.0f}/100 ({q['health_status']})")
        print()

    if component is None or component == "agents":
        a = data["agents"]
        a_emoji = get_health_emoji(a["health_score"])
        print(f"{a_emoji} Agent Status")
        print("-" * 30)
        print(f"  Online  : {a['online']}")
        print(f"  Stale   : {a['stale']}")
        print(f"  Offline : {a['offline']}")
        print(f"  Total   : {a['total']}")
        print(f"  Health  : {a['health_score']:.0f}/100 ({a['health_status']})")
        print()

    if component is None:
        t = data["throughput"]
        print(f"ðŸ“Š Throughput")
        print("-" * 30)
        print(f"  Tasks/Day : {t['tasks_per_day']} (target: {t['target']})")
        print()

        # Commit compliance
        c = data.get("compliance", {})
        if c:
            compliance_rate = c.get('compliance_rate', 0)
            threshold = c.get('threshold', 75)
            meets = c.get('meets_threshold', False)
            color_emoji = "ðŸŸ¢" if meets else "ðŸ”´"
            print(f"{color_emoji} Commit Compliance")
            print("-" * 30)
            print(f"  Rate      : {compliance_rate:.1f}% (threshold: {threshold}%)")
            print(f"  With      : {c.get('with_commits', 0)} / {c.get('total_tasks', 0)} tasks")
            if not meets:
                print(f"  âš ï¸  Below threshold - {c.get('without_commits', 0)} tasks need commits")
            print()

    if data["stuck_tasks"] and (component is None or component == "queue"):
        print(f"âš ï¸  Stuck Tasks ({len(data['stuck_tasks'])})")
        print("-" * 30)
        for st in data["stuck_tasks"][:5]:
            print(f"  {st['id']}: {st['title'][:40]}")
            print(f"    Reason: {st['reason']}")
            print(f"    Duration: {st['duration']}")
        if len(data["stuck_tasks"]) > 5:
            print(f"  ... and {len(data['stuck_tasks']) - 5} more")
        print()


def output_json(data: dict) -> None:
    """Output data as JSON."""
    print(json.dumps(data, indent=2))


def output_csv(data: dict) -> None:
    """Output data as CSV."""
    writer = csv.writer(sys.stdout)
    writer.writerow(["component", "metric", "value"])

    writer.writerow(["system", "health_score", data["health_score"]])
    writer.writerow(["system", "status", data["status"]])

    for key, value in data["queue"].items():
        writer.writerow(["queue", key, value])

    for key, value in data["agents"].items():
        writer.writerow(["agents", key, value])

    writer.writerow(["throughput", "tasks_per_day", data["throughput"]["tasks_per_day"]])


def watch_mode(interval: int, component: str = None) -> None:
    """Run in watch mode with refresh."""
    try:
        while True:
            # Clear screen
            print("\033[2J\033[H", end="")
            data = get_health_snapshot()
            output_table(data, component)
            print(f"\nRefreshing every {interval}s (Ctrl+C to exit)")
            time.sleep(interval)
    except KeyboardInterrupt:
        print("\nExiting...")


def main():
    parser = argparse.ArgumentParser(
        description="BB5 Health - System health monitoring",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    bb5-health                    # Full health snapshot
    bb5-health -f json            # JSON output
    bb5-health -q                 # Queue stats only
    bb5-health -w 5               # Refresh every 5 seconds
        """
    )
    parser.add_argument(
        "-f", "--format",
        choices=["table", "json", "csv"],
        default="table",
        help="Output format (default: table)"
    )
    parser.add_argument(
        "-q", "--queue",
        action="store_true",
        help="Show queue stats only"
    )
    parser.add_argument(
        "-a", "--agents",
        action="store_true",
        help="Show agent stats only"
    )
    parser.add_argument(
        "-s", "--system",
        action="store_true",
        help="Show system health only"
    )
    parser.add_argument(
        "-w", "--watch",
        type=int,
        metavar="SECONDS",
        help="Watch mode with refresh interval"
    )
    parser.add_argument(
        "--save",
        action="store_true",
        help="Save snapshot to database"
    )

    args = parser.parse_args()

    # Determine component filter
    component = None
    if args.queue:
        component = "queue"
    elif args.agents:
        component = "agents"
    elif args.system:
        component = "system"

    # Initialize database if saving
    if args.save:
        init_database()

    if args.watch:
        watch_mode(args.watch, component)
    else:
        data = get_health_snapshot()

        if args.save:
            from health_monitor.models import HealthStatus
            snapshot = HealthSnapshot(
                timestamp=datetime.now(),
                health_score=data["health_score"],
                status=HealthStatus(data["status"]),
                queue_pending=data["queue"]["pending"],
                queue_in_progress=data["queue"]["in_progress"],
                queue_completed=data["queue"]["completed"],
                agents_online=data["agents"]["online"],
                agents_stale=data["agents"]["stale"],
                agents_total=data["agents"]["total"],
                stuck_tasks=len(data["stuck_tasks"]),
            )
            save_snapshot(snapshot, data["details"])
            print(f"Snapshot saved to database")

        if args.format == "json":
            output_json(data)
        elif args.format == "csv":
            output_csv(data)
        else:
            output_table(data, component)


if __name__ == "__main__":
    main()
