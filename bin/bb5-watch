#!/usr/bin/env python3
"""BB5 Watch - Daemon control for continuous health monitoring.

Usage:
    bb5-watch start [options]
    bb5-watch stop
    bb5-watch status
    bb5-watch restart
    bb5-watch logs

Options:
    -i, --interval SECONDS  Check interval (default: 30)
    -t, --telegram          Enable Telegram alerts
    --token TOKEN           Telegram bot token
    --chat-id CHAT_ID       Telegram chat ID
    -d, --daemon            Run as daemon (background)
    -h, --help              Show this help message

Environment Variables:
    TELEGRAM_BOT_TOKEN      Telegram bot token
    TELEGRAM_CHAT_ID        Telegram chat ID
    WEBHOOK_URL             Webhook URL for alerts
    BB5_HOME                BB5 installation directory

Examples:
    bb5-watch start                    # Start monitoring
    bb5-watch start -t                 # Start with Telegram alerts
    bb5-watch start -d -i 60           # Daemon mode, 60s interval
    bb5-watch stop                     # Stop daemon
    bb5-watch status                   # Check daemon status
    bb5-watch logs                     # Show recent logs
"""

import argparse
import logging
import os
import signal
import subprocess
import sys
import time
from pathlib import Path

# Add lib to path
sys.path.insert(0, str(Path(__file__).parent / "lib"))

from health_monitor.daemon import (
    MonitoringDaemon,
    DaemonConfig,
    PIDManager,
    get_default_pid_file,
)
from health_monitor.alerts import AlertManager, AlertConfig, create_alert_manager_from_env
from health_monitor.database import init_database


def setup_logging(log_file: Path = None) -> logging.Logger:
    """Setup logging configuration."""
    logger = logging.getLogger("bb5_watch")
    logger.setLevel(logging.INFO)

    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )

    # Console handler
    console = logging.StreamHandler()
    console.setFormatter(formatter)
    logger.addHandler(console)

    # File handler
    if log_file:
        log_file.parent.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    return logger


def get_log_file() -> Path:
    """Get default log file path."""
    bb5_home = Path(os.environ.get("BB5_HOME", os.path.expanduser("~/.blackbox5")))
    return bb5_home / ".autonomous" / "health" / "watch.log"


def start_daemon(
    interval: int = 30,
    alert_manager: AlertManager = None,
    daemon_mode: bool = False,
    health_threshold: int = 60,
    heartbeat_timeout: int = 120,
) -> bool:
    """Start the monitoring daemon."""
    pid_file = get_default_pid_file()
    pid_mgr = PIDManager(pid_file)

    # Check if already running
    if pid_mgr.is_running():
        print(f"Daemon already running (PID: {pid_mgr.read()})")
        return False

    # Initialize database
    init_database()

    log_file = get_log_file()
    logger = setup_logging(log_file)

    config = DaemonConfig(
        check_interval_seconds=interval,
        health_score_threshold=health_threshold,
        heartbeat_timeout_seconds=heartbeat_timeout,
        pid_file=pid_file,
        log_file=log_file,
    )

    daemon = MonitoringDaemon(config, alert_manager)

    # Write PID file
    pid_mgr.write()

    logger.info(f"Starting BB5 Watch daemon (interval: {interval}s)")
    print(f"Starting BB5 Watch daemon...")
    print(f"  Interval: {interval}s")
    print(f"  Log file: {log_file}")
    print(f"  PID file: {pid_file}")

    if alert_manager and alert_manager.config.telegram_enabled:
        print(f"  Telegram alerts: enabled")
    else:
        print(f"  Telegram alerts: disabled")

    if daemon_mode:
        # Fork to background
        try:
            pid = os.fork()
            if pid > 0:
                # Parent process
                print(f"Daemon started (PID: {pid})")
                return True
        except OSError as e:
            logger.error(f"Fork failed: {e}")
            return False

    try:
        daemon.run()
    except Exception as e:
        logger.error(f"Daemon error: {e}", exc_info=True)
        pid_mgr.remove()
        return False

    return True


def stop_daemon() -> bool:
    """Stop the monitoring daemon."""
    pid_file = get_default_pid_file()
    pid_mgr = PIDManager(pid_file)

    pid = pid_mgr.read()
    if not pid:
        print("Daemon not running")
        return False

    if not pid_mgr.is_running():
        print(f"Daemon not running (stale PID file removed)")
        pid_mgr.remove()
        return False

    try:
        os.kill(pid, signal.SIGTERM)
        print(f"Daemon stopped (PID: {pid})")

        # Wait for process to exit
        for _ in range(10):
            if not pid_mgr.is_running():
                break
            time.sleep(0.5)

        pid_mgr.remove()
        return True
    except ProcessLookupError:
        print(f"Daemon not running (stale PID file removed)")
        pid_mgr.remove()
        return False
    except Exception as e:
        print(f"Error stopping daemon: {e}")
        return False


def get_daemon_status() -> dict:
    """Get daemon status."""
    pid_file = get_default_pid_file()
    pid_mgr = PIDManager(pid_file)

    pid = pid_mgr.read()
    is_running = pid_mgr.is_running()

    status = {
        "running": is_running,
        "pid": pid,
        "pid_file": str(pid_file),
        "log_file": str(get_log_file()),
    }

    # Get last log lines
    log_file = get_log_file()
    if log_file.exists():
        try:
            with open(log_file, "r") as f:
                lines = f.readlines()
                status["last_logs"] = lines[-10:] if len(lines) > 10 else lines
        except Exception:
            status["last_logs"] = []
    else:
        status["last_logs"] = []

    return status


def show_status():
    """Display daemon status."""
    status = get_daemon_status()

    if status["running"]:
        print(f"Daemon status: [RUNNING] (PID: {status['pid']})")
    else:
        print("Daemon status: [STOPPED]")

    print(f"  PID file: {status['pid_file']}")
    print(f"  Log file: {status['log_file']}")

    if status["last_logs"]:
        print("\nRecent logs:")
        for line in status["last_logs"]:
            print(f"  {line.rstrip()}")


def show_logs(lines: int = 50):
    """Show daemon logs."""
    log_file = get_log_file()

    if not log_file.exists():
        print(f"No log file found: {log_file}")
        return

    try:
        with open(log_file, "r") as f:
            all_lines = f.readlines()
            for line in all_lines[-lines:]:
                print(line.rstrip())
    except Exception as e:
        print(f"Error reading logs: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="BB5 Watch - Daemon control for health monitoring",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
    start                   Start the monitoring daemon
    stop                    Stop the daemon
    status                  Show daemon status
    restart                 Restart the daemon
    logs                    Show recent logs

Examples:
    bb5-watch start                    # Start monitoring
    bb5-watch start -t                 # Start with Telegram alerts
    bb5-watch start -d -i 60           # Daemon mode, 60s interval
    bb5-watch stop                     # Stop daemon
    bb5-watch status                   # Check daemon status
        """
    )

    parser.add_argument(
        "command",
        choices=["start", "stop", "status", "restart", "logs"],
        help="Command to execute"
    )
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=30,
        help="Check interval in seconds (default: 30)"
    )
    parser.add_argument(
        "-t", "--telegram",
        action="store_true",
        help="Enable Telegram alerts"
    )
    parser.add_argument(
        "--token",
        help="Telegram bot token"
    )
    parser.add_argument(
        "--chat-id",
        help="Telegram chat ID"
    )
    parser.add_argument(
        "-d", "--daemon",
        action="store_true",
        help="Run as daemon (background)"
    )
    parser.add_argument(
        "--threshold",
        type=int,
        default=60,
        help="Health score alert threshold (default: 60)"
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=120,
        help="Heartbeat timeout in seconds (default: 120)"
    )
    parser.add_argument(
        "-n", "--lines",
        type=int,
        default=50,
        help="Number of log lines to show (default: 50)"
    )

    args = parser.parse_args()

    if args.command == "start":
        # Setup alert manager
        alert_manager = None

        if args.telegram or args.token:
            config = AlertConfig(
                telegram_enabled=True,
                telegram_bot_token=args.token or os.environ.get("TELEGRAM_BOT_TOKEN"),
                telegram_chat_id=args.chat_id or os.environ.get("TELEGRAM_CHAT_ID"),
                min_severity="warning",
            )

            if not config.telegram_bot_token or not config.telegram_chat_id:
                print("Error: Telegram alerts require bot token and chat ID")
                print("Set TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID environment variables")
                print("Or use --token and --chat-id options")
                sys.exit(1)

            alert_manager = AlertManager(config)
        else:
            # Try to create from environment
            alert_manager = create_alert_manager_from_env()
            if not alert_manager.config.telegram_enabled:
                alert_manager = None

        success = start_daemon(
            interval=args.interval,
            alert_manager=alert_manager,
            daemon_mode=args.daemon,
            health_threshold=args.threshold,
            heartbeat_timeout=args.timeout,
        )
        sys.exit(0 if success else 1)

    elif args.command == "stop":
        success = stop_daemon()
        sys.exit(0 if success else 1)

    elif args.command == "status":
        show_status()

    elif args.command == "restart":
        stop_daemon()
        time.sleep(1)

        # Setup alert manager
        alert_manager = create_alert_manager_from_env()
        if not alert_manager.config.telegram_enabled:
            alert_manager = None

        success = start_daemon(
            interval=args.interval,
            alert_manager=alert_manager,
            daemon_mode=args.daemon,
            health_threshold=args.threshold,
            heartbeat_timeout=args.timeout,
        )
        sys.exit(0 if success else 1)

    elif args.command == "logs":
        show_logs(args.lines)


if __name__ == "__main__":
    main()
