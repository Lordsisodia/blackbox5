source:
  type: youtube
  id: hswNmY8gWbE
  url: https://youtube.com/watch?v=hswNmY8gWbE
  title: Tanstack Start overview (by a nextjs fanboy)
  description: "Discover TanStack Start, the newest React meta framework. I cover\
    \ what it is, key features, and why it matters for modern React apps.\n\nMy Links:\n\
    \U0001F310 My Site: https://rasmic.link/site\n\U0001F3ED My product studio: https://rasmic.link/fabrika\n\
    ⚡ Nextjs Starter Kit: https://rasmic.link/next-starter\n⚛️ React Starter kit:\
    \ https://rasmic.link/react-starter\n\nSocials:\n\U0001F426 Follow me on X: https://rasmic.link/x\n\
    \U0001F4AC Join my Discord: https://rasmic.link/discord\n▶️ Subscribe to my second\
    \ channel: https://rasmic.link/more-micky\n\nTools I use: \n\U0001F4DA Programming\
    \ courses: https://rasmic.link/scrimba\n\U0001F3A5 Recording Software: https://rasmic.link/screen-studio"
  channel: Ras Mic
  channel_id: UCBX__dPYqDFqAN4QcWbnUbw
  published_at: '20251119'
  duration: 1049
  view_count: 10302
  like_count: 373
  thumbnail: https://i.ytimg.com/vi_webp/hswNmY8gWbE/maxresdefault.webp
creator:
  name: Rasmus
  slug: rasmus
  handle: '@rasmic'
  tier: 1
  areas:
  - ai-engineering
  - coding-tools
  topics:
  - ai-development
  - technical-deep-dives
collection:
  discovered_via: rss
  discovered_at: '2026-02-02T03:27:25.081391'
  collected_at: '2026-02-02T03:27:25.081398'
  collected_by: ingest.py
transcript:
  full_text: A new React meta framework is upon us, ladies and gents. Tanstack start
    is in RC. This is already the most anticipated, the most loved, the most hyped
    about React meta framework, but it's not without reason. In today's video, I'm
    going to give you a crash course on everything Tanstack start. We're going to
    do an overview on Tanstack Start. We're going to set up a Tanstack start project.
    We're going to talk about routing, server functions, environment functions, middleware,
    server routes. And I have no doubt after this video you're going to get a good
    sense of tanstack start. So sit back, relax, let's get started. So we [snorts]
    all love Tanstack for the amazing dev tools that they created in particular for
    myself. Tanstack query in my opinion is the best state management utility library
    that exists in the React ecosystem. But then they went ahead and built Tanstack
    router which is a type- safe router for React and solid applications. Tanstack
    start seems to be tanstack router and all the missing features a meta framework
    built on React needs. And here it tells you 90% of any framework usually comes
    down to the router. Tanstack start is no different. Tanstack start relies 100%
    on Tanstack router for its routing system. In addition to Tanstack Router's amazing
    features, Tanstack start enables even more powerful features like full document
    SSR streaming server routes and API routes, server functions, middleware, full
    stack bundling. You can deploy this thing anywhere and end to end type safety.
    By the way, when they say end to end type safety, they mean everything. Everything's
    type safe. Now, there is one limitation that they document here and it's that
    they don't support React server components. But depending on what you think about
    React server components, this might be a good thing, but they are actively working
    on it and it should be coming in the near future. So, let's set up a Tanstack
    start project. So, I'm going to copy this npx command and I'm just going to paste
    this here. And what's going to do is going to scaffold a basic Tanstack start
    [music] project. Okay, I have my project running. I'm going to do npm rundev and
    we're going to open localhost 3000 in a new tab and I see a basic sample project.
    Now if you go to their docs they have richer examples with integrations with different
    DB providers. I just wanted to start off basic so we can build on each topic I
    want to go [music] over in this video. So we did a quick overview. We set up our
    project. Let's talk about routing. Now we know that Tanstack start uses Tanstack
    router as [music] its router. And when we go to the Tanstack router documentation,
    there are actually different ways of handling routing. Uh my favorite one being
    filebased routing. I think I've used Nex.js so much that file-based routing just
    makes more sense to me. But there's uh virtual file routes where you define routes
    in code. There's codebased routing, right, where the name of the file dictates
    how uh the route is. I'm just going to stick to file-based routing because it
    makes the most sense. And if you're not familiar with filebased routing, if I
    wanted to have a /post route, I would essentially have a post folder. And under
    the post folder, I would have index.tsx instead of page.tsx. In Nex.js, we do
    page.tsx, but in tanstack, you would do index.tsx. So, this would take you to
    the /post route, the exact route. But then, if you did dollar sign post ID.tsx,
    tsx. What it's going to do is it's going to do /ost slash whatever ID that you
    would then get from the URL and maybe use that ID to search your DB and render
    whatever host that you have. But here's another thing that you need to know. If
    you just wanted to name a page about and you don't want to create a folder, you
    can do about.tsx and that's the page. Post.tsx, that's the page. I think because
    I'm familiar and I've used Nex.js a lot, I'm going to go with creating a folder
    than index.tsx. Maybe I'll just have the route be the file name, but for now,
    this is the convention I want to follow. [music] So, here's what we're going to
    do. I'm going to create a route in my Tanstack start project. We're going to go
    under routes. You see, there are already plenty of routes created for us, but
    let's create a new one. I'm going to create a new file. We're going to create
    a dashboard folder by typing in dashboard and adding [music] a slash. If I hit
    enter, it creates a folder. And in here, I'm just going to create index.tsx. Now,
    I'm about to hit enter. I want you to see what happens when I create this new
    file. some code is generated for me and you can see this is code that panstack
    router generates for you. This is the code you need to register this as a router.
    So if I go to my localhost 3000 and I enter /dashboard, I see hello/dashboard
    and that's exactly the code [music] that was generated. And again, if I wanted
    to create a nested layout, what I would do is I create a new file dollar sign.
    I can do dashboard id.tsx. And you see slash dashboards/dashboard ID. Now you
    see I have slash dashboard slign dashboard ID. But I hit 1 2 3/123. How do I extract
    the number? I'm going to go back to my dashboard ID file. And autocomplete just
    took care of it. I'm going to do route.params which is a hook that tanstack start
    [music] gives me. And I can extract the dashboard ID and I can literally just
    swap or I'll just add this here. And then if I go back to the page, I can see
    if I even add some more numbers that I now have the ID from the route. So this
    is pretty much what you need in order to do routing in tanstack star. You can
    see on the basic starter project, if I click on posts and I click on a specific
    post, uh post renders. Now if I look at the routing here, I see post.index.tsx
    and I see post dot dollar signpost id.tsx. tsx. So, this is again another way
    you can do routing. But if I wanted to replicate this in a and use filebased routing,
    all I would do is create a posts uh folder. And under the post folder, I'm just
    going to do index.tsx. And then I'm just going to copy the post.index.tsx file.
    And I'm going to paste it in here. And then I'm going to delete this file because
    I no longer need it. And then what I'm going to do is the post dot dollar sign
    post id. I'm going to copy that and under here I'm going to do post actually dollar
    sign post id.tsx and I'm going to paste the code here. So I'm going to make sure
    this gets imported properly and I am going to delete this file. Now after deleting
    this and saving if I go back to post you see it works just like it did earlier
    right so you can pick however you want to handle routing I like using filebased
    routing so now that we've done routing let's talk server functions server functions
    let you define serveronly logic that can be called from anywhere in your application
    loaders components hooks or other server functions they run on the server but
    can be invoked from client code seamlessly so another mental model for you to
    think of is almost like server actions. But unlike server actions, with server
    functions in tanstack start, you can do get requests. You can use them to fetch
    data. And this is how you invoke a server function. You call create server function
    from tanstack start. And then you call the handler and then in the handler you
    write whatever async function, async code and then you can call that anywhere
    in a component, in a loader, in a hook. We have a simple example here where under
    the utils folder we have a file called post.tsx and in the post.tsx tsx we have
    this fetch posts [music] server function right and then in the handler all we
    have is us fetching posts from this random API if the request fails then we throw
    an error if it doesn't we extract the post and we return the post we return 10
    posts and here's the thing now I can call this fetch post pretty much anywhere
    so I can go in my post route and you can see in the route configuration I have
    what's called a loader. If you've ever used uh React Router V7 or Remix version
    2, then you are familiar with loaders. You basically can load in data and it becomes
    available to that component. So in this loader, we see that we're fetching posts.
    [music] And what I can do is I can use the use loader data hook to get the posts
    and render the posts in JSX. I really like this mental model because fetching
    data in a component is a lot easier when you just load it [music] in using the
    loader. Now going back to this server function, we see that this is just fetching
    data that this is essentially a get request and we don't have it defined here
    because by default a server function is a get request. But you can specify the
    method to be get here. But what if you want to do a post request? With server
    functions, it's pretty simple. All you have to do is specify the method post and
    you would do the same exact thing. You write your function here. In this case,
    we're taking in an ID, passing it to this endpoint to give us the specific blog
    post. Doing get requests is easy with Tanstack start. Doing post requests is easy
    with Tanstack start. You're just going to use a server function. But here's what
    makes server functions even cooler. You see right before the handler, we see this
    input validator. Now what this input validator does, it basically checks the type
    of the data that we're receiving. So we're basically telling it the data that
    we receive has to be a string. And I can check this. Let me go back to my localhost
    3000 and let me click on a specific post. If I look at the console log, I I can
    see fetching post with ID4. And that's exactly what's happening here. The data
    I'm receiving is the ID and the ID is a string. But let's say I change the string
    to boolean, right? And I hit save. Notice how I get an error right away on post
    ID. And if I hover over it here, it says string is not assignable to type boolean.
    Here is that end to-end type safety we were promised. So I'm going to do is go
    back and return this back to string. Hit save. If I hover over post ID, I see
    the type. You can be a lot more aggressive with the validator. I I for example
    can say if this ID is not a type string, throw in an error. So what I can do here
    is I can change this to being boolean and then if I go and click on a post notice
    how I get this error because again the validator failed. So you can be pretty
    aggressive with this input validator if you want to. You can also do your off
    checks in server functions. You can see here you can await current user and if
    you don't find the user you can redirect them back to the login page. Now I will
    say this as an X.js fanboy. I prefer server actions in Tanstack start over Nex.js's
    server actions. Now we talked about routing server functions. Let's talk about
    environment functions. So environment functions are different to server functions.
    How are they different? Well, for starters, server functions are server only logic
    that can be called anywhere in the application. Meaning you write this function
    that is in the server, but you can call it on the client. With environment functions,
    it's different. It allows you to pick where you run the function. So whether you
    run this code in the client in the server, you get to choose. Now you might be
    wondering when does it make sense to run on the server? When does it make sense
    to run on the client? Let's say you have a function that's creating and deleting
    files, right? Like you're using the local file system. That's going to be an environment
    function that runs only on the server. You would use something like create server
    only function. But let's say you wanted to use the browser API like window dot
    or whatever other browser API you choose to use. You're going to use a create
    clienton function. But let's say you wanted to use both. You can use create isomeorphic
    function and then do dots server and define what it should do on the server and
    then you can do doclient and define what it should do on the client. And this
    is particularly cool when handling environment variables. You can use create isomeorphic
    functions to basically split what environment variables are available on the client,
    what environment variables are available on the server. So let's write an isomorphic
    function, an environment function. I'm basically going to copy this example. [music]
    And you're going to see here in post.tsx, I have a create isomeorphic function
    here. And on the server, it's going to return server. And on the client, it's
    going to return client. Here's what's cool about this. I created a new route called
    test. I'm using filebased routing. So I have my index.tsx here. And in the route
    configuration I can specify if SSR is true or false. So I have SSR as false and
    I'm calling my isomeorphic function. Can you guess when I console log what should
    be returned? If I go to my tanstack start app page and I inspect and I have console
    and I refresh, you're going to see client being rendered. Why? Because the way
    this isomorphic function is written is that if it knows it's being called on the
    client, then it's going to return client. What if let's go back to my test route.
    What if I have SSR is true? And then we hit save. If I refresh my page, I'm going
    to see server being returned. Here's what you need to understand. Even though
    SSR is true, if I refresh, you're going to see client being logged too. But we
    thought this page SSR [music] is true. Here's the thing. See when we specified
    server here, this will only run on the server. It will not run on a client. And
    here what we have specified as client will never run on the server. We see it
    running on the client. The reason why I think this is powerful is we have this
    clear separation between server and client that I think is sometimes blurred with
    Nex.js and can be difficult to navigate, especially if you're a newbie. But honestly,
    if you want, you could just specify server only function, client only function.
    Now let's talk about Tanstack's middleware. Now the docs tell us what we can do
    in the middleware. [music] We can have authentication, authorization, logging.
    We can have uh content security policies. We can do observability. We can use
    it to provide context error handling. So the middleware in Tanstack start is very
    rich and powerful. It's the middleware we're used to in Node.js. Here I have a
    simple logging middleware. I I'm going to use the create middleware function to
    create this. I specify this runs on the server and all I want to do is just console
    log context that I get and get the request headers. Now here's how cool middleware
    and tan stack start is. I can run this middleware in the server function but before
    it the handler runs. So I can have a middleware you can have an O middleware where
    before someone calls a server function you make sure they're authenticated. Right?
    This is great security practice. [music] In this case, when I fetch posts, I should
    see a log. And I'm already seeing the log. But just to test this, I'm going to
    refresh this page. I'm going to click on a couple posts. And you see the request
    headers being console logged. And I get no context here because I don't have any
    off or anything that I'm passing. But and you can chain many of these, right?
    I can add another middleware if I want to, an off middleware, a logging middleware,
    observability, whatever it is, redirection. You can get as creative as you want
    with your middleware, but the developer experience in my opinion is so easy. You
    just define it and then you can attach it to whatever server function you want
    to run that middleware. What's cool is you can run middleware on all the server
    routes. So let's say you've defined a get request or post request and before someone
    hits you want to log that or you have some sort of authentication, you can specify
    that middleware in the route for server routes. And last but not least, let's
    talk about server routes. Server routes allow you to create serverside endpoints
    in your application that are useful for handling raw HTTP requests. So if you
    want to expose API to a thirdparty service to another app, you just want to create
    API routes, you can do that with Tanstack router. You would do that in the route
    configuration, you would specify in the server, you would have handlers and you
    specify the request type, get, post, whatever request type that you want to have.
    I have a simple example here where we have a get request. This is going to be
    / API/ users. And basically what you're going to get is you're going to get uh
    a user information. So if I go to localhost/appi/ users and I hit enter, I get
    information from the API route. And again, just like we talked about in the previous
    section for middleware, you can have specific middleware here. It's just a test
    middleware, but I can also log users information. There's so much you can do with
    all these different building blocks, piecing them together. Tanstack start is
    really a great full stack solution. And ladies and gents, that completes the Tanstack
    Start RC course. Now, this is not production ready. RC means release candidate.
    So, it's very close to 1.0. I believe in release candidate you don't change, you
    don't do any breaking changes, but you basically are fixing any bugs or issues
    that the community is reporting. But I would get started, learn, use it. It definitely
    feels fresh. I would say this is the one framework I've used where I'm like, huh,
    I kind of do like this. And this does compare to Nex.js. And there are some projects
    I want to use this for to see if building a full scale application works and feels
    right. But so far, ladies and gents, this might be the one. This might be the
    killer. This might be the top dog. Would love to know your thoughts on Tanstack
    Start. Let me know if you enjoyed this video in the comments section. Make sure
    to like, comment, subscribe, hit the notification bell. Thank you so much for
    watching. I'll see you in the next one.
  segments:
  - start: 00:00:00
    text: A new React meta framework is upon us,
  - start: 00:00:02
    text: ladies and gents. Tanstack start is in
  - start: 00:00:05
    text: RC. This is already the most
  - start: 00:00:06
    text: anticipated, the most loved, the most
  - start: 00:00:08
    text: hyped about React meta framework, but
  - start: 00:00:11
    text: it's not without reason. In today's
  - start: 00:00:12
    text: video, I'm going to give you a crash
  - start: 00:00:14
    text: course on everything Tanstack start.
  - start: 00:00:16
    text: We're going to do an overview on
  - start: 00:00:17
    text: Tanstack Start. We're going to set up a
  - start: 00:00:19
    text: Tanstack start project. We're going to
  - start: 00:00:20
    text: talk about routing, server functions,
  - start: 00:00:22
    text: environment functions, middleware,
  - start: 00:00:24
    text: server routes. And I have no doubt after
  - start: 00:00:26
    text: this video you're going to get a good
  - start: 00:00:28
    text: sense of tanstack start. So sit back,
  - start: 00:00:30
    text: relax, let's get started. So we [snorts]
  - start: 00:00:32
    text: all love Tanstack for the amazing dev
  - start: 00:00:35
    text: tools that they created in particular
  - start: 00:00:36
    text: for myself. Tanstack query in my opinion
  - start: 00:00:39
    text: is the best state management utility
  - start: 00:00:41
    text: library that exists in the React
  - start: 00:00:42
    text: ecosystem. But then they went ahead and
  - start: 00:00:44
    text: built Tanstack router which is a type-
  - start: 00:00:46
    text: safe router for React and solid
  - start: 00:00:48
    text: applications. Tanstack start seems to be
  - start: 00:00:51
    text: tanstack router and all the missing
  - start: 00:00:54
    text: features a meta framework built on React
  - start: 00:00:56
    text: needs. And here it tells you 90% of any
  - start: 00:00:59
    text: framework usually comes down to the
  - start: 00:01:00
    text: router. Tanstack start is no different.
  - start: 00:01:03
    text: Tanstack start relies 100% on Tanstack
  - start: 00:01:05
    text: router for its routing system. In
  - start: 00:01:06
    text: addition to Tanstack Router's amazing
  - start: 00:01:08
    text: features, Tanstack start enables even
  - start: 00:01:11
    text: more powerful features like full
  - start: 00:01:12
    text: document SSR streaming server routes and
  - start: 00:01:15
    text: API routes, server functions,
  - start: 00:01:17
    text: middleware, full stack bundling. You can
  - start: 00:01:19
    text: deploy this thing anywhere and end to
  - start: 00:01:21
    text: end type safety. By the way, when they
  - start: 00:01:23
    text: say end to end type safety, they mean
  - start: 00:01:24
    text: everything. Everything's type safe. Now,
  - start: 00:01:26
    text: there is one limitation that they
  - start: 00:01:27
    text: document here and it's that they don't
  - start: 00:01:29
    text: support React server components. But
  - start: 00:01:32
    text: depending on what you think about React
  - start: 00:01:34
    text: server components, this might be a good
  - start: 00:01:36
    text: thing, but they are actively working on
  - start: 00:01:37
    text: it and it should be coming in the near
  - start: 00:01:39
    text: future. So, let's set up a Tanstack
  - start: 00:01:42
    text: start project. So, I'm going to copy
  - start: 00:01:44
    text: this npx command and I'm just going to
  - start: 00:01:46
    text: paste this here. And what's going to do
  - start: 00:01:48
    text: is going to scaffold a basic Tanstack
  - start: 00:01:51
    text: start [music] project. Okay, I have my
  - start: 00:01:52
    text: project running. I'm going to do npm
  - start: 00:01:54
    text: rundev and we're going to open localhost
  - start: 00:01:58
    text: 3000 in a new tab and I see a basic
  - start: 00:02:01
    text: sample project. Now if you go to their
  - start: 00:02:03
    text: docs they have richer examples with
  - start: 00:02:05
    text: integrations with different DB
  - start: 00:02:06
    text: providers. I just wanted to start off
  - start: 00:02:08
    text: basic so we can build on each topic I
  - start: 00:02:10
    text: want to go [music] over in this video.
  - start: 00:02:11
    text: So we did a quick overview. We set up
  - start: 00:02:13
    text: our project. Let's talk about routing.
  - start: 00:02:16
    text: Now we know that Tanstack start uses
  - start: 00:02:18
    text: Tanstack router as [music] its router.
  - start: 00:02:20
    text: And when we go to the Tanstack router
  - start: 00:02:22
    text: documentation, there are actually
  - start: 00:02:24
    text: different ways of handling routing. Uh
  - start: 00:02:26
    text: my favorite one being filebased routing.
  - start: 00:02:28
    text: I think I've used Nex.js so much that
  - start: 00:02:30
    text: file-based routing just makes more sense
  - start: 00:02:32
    text: to me. But there's uh virtual file
  - start: 00:02:34
    text: routes where you define routes in code.
  - start: 00:02:36
    text: There's codebased routing, right, where
  - start: 00:02:38
    text: the name of the file dictates how uh the
  - start: 00:02:41
    text: route is. I'm just going to stick to
  - start: 00:02:43
    text: file-based routing because it makes the
  - start: 00:02:45
    text: most sense. And if you're not familiar
  - start: 00:02:47
    text: with filebased routing, if I wanted to
  - start: 00:02:49
    text: have a /post route, I would essentially
  - start: 00:02:52
    text: have a post folder. And under the post
  - start: 00:02:55
    text: folder, I would have index.tsx instead
  - start: 00:02:57
    text: of page.tsx. In Nex.js, we do page.tsx,
  - start: 00:03:01
    text: but in tanstack, you would do index.tsx.
  - start: 00:03:04
    text: So, this would take you to the /post
  - start: 00:03:06
    text: route, the exact route. But then, if you
  - start: 00:03:08
    text: did dollar sign post ID.tsx, tsx. What
  - start: 00:03:11
    text: it's going to do is it's going to do
  - start: 00:03:12
    text: /ost slash whatever ID that you would
  - start: 00:03:16
    text: then get from the URL and maybe use that
  - start: 00:03:18
    text: ID to search your DB and render whatever
  - start: 00:03:20
    text: host that you have. But here's another
  - start: 00:03:22
    text: thing that you need to know. If you just
  - start: 00:03:23
    text: wanted to name a page about and you
  - start: 00:03:25
    text: don't want to create a folder, you can
  - start: 00:03:27
    text: do about.tsx and that's the page.
  segment_count: 475
  language: en
  is_auto_generated: true
processing:
  stage: ingested
  stages_completed:
  - ingest
  next_stage: extract
