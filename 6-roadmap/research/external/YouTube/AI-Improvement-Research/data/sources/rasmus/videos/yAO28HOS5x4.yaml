source:
  type: youtube
  id: yAO28HOS5x4
  url: https://youtube.com/watch?v=yAO28HOS5x4
  title: My Complete Tech & Tool Stack (Everything)
  description: "I'm going to share with you my complete tech and tool stack.\n\nMy\
    \ Links:\n\U0001F310 My Site: https://rasmic.link/site\n\U0001F3ED My product\
    \ studio: https://rasmic.link/fabrika\n⚡ Nextjs Starter Kit: https://rasmic.link/next-starter\n\
    ⚛️ React Starter kit: https://rasmic.link/react-starter\n\nSocials:\n\U0001F426\
    \ Follow me on X: https://rasmic.link/x\n\U0001F4AC Join my Discord: https://rasmic.link/discord\n\
    ▶️ Subscribe to my second channel: https://rasmic.link/more-micky\n\nTools I use:\
    \ \n\U0001F310 Framer (use RASMIC for 2 months free of Framer Pro): https://rasmic.link/framer\n\
    \U0001F4DA Programming courses: https://rasmic.link/scrimba\n\U0001F4F8 My Camera:\
    \ https://rasmic.link/camera\n\U0001F4FA Screen Recording Software: https://rasmic.link/screen-studio"
  channel: Ras Mic
  channel_id: UCBX__dPYqDFqAN4QcWbnUbw
  published_at: '20260123'
  duration: 1314
  view_count: 13330
  like_count: 715
  thumbnail: https://i.ytimg.com/vi_webp/yAO28HOS5x4/maxresdefault.webp
creator:
  name: Rasmus
  slug: rasmus
  handle: '@rasmic'
  tier: 1
  areas:
  - ai-engineering
  - coding-tools
  topics:
  - ai-development
  - technical-deep-dives
collection:
  discovered_via: rss
  discovered_at: '2026-02-02T03:26:13.380286'
  collected_at: '2026-02-02T03:26:13.380294'
  collected_by: ingest.py
transcript:
  full_text: With AI writing a good chunk of the code, now more than ever, the tools
    we use matter. That's why in today's video, I'm going to be sharing with you all
    the tools that I use, my web and mobile frameworks, what I use for styling, what
    I use for payments, what I use for authentication, the tools I use to build AI
    apps, where I deploy my applications, the AI tools I use to build my applications,
    what models do I use. Is it just Opus 4.5 or is there another model? What chat
    apps did I use? I'm literally going to be sharing with you my entire tech and
    tool stack that I use when shipping apps using AI. We're going to get in the weeds
    with this one. I hope you're ready. I hope you're excited. Let's get into it.
    So, first things first, let's talk about the web and mobile frameworks I use.
    What tools do I use to build my web and mobile applications? And for the most
    part, this has been pretty standard. There is a new addition to the pack, and
    I'll explain why in a second. But I genuinely believe with all these tools, I
    can ship any web and mobile app. So if you've been watching my YouTube channel,
    you know that I've been a big fan of Nex.js and I've been using Nex.js for quite
    some time now. I know there's some of you that are probably going to say, why
    not Tanstack Start? And I've played around with Tanstack Start. It's actually
    really great. My only qualms with it is there are actually two things. First and
    foremost, the AI models have not been trained on it. So it definitely does hallucinate.
    Now, I know you can probably add some skills or some like example code or some
    snippets and it'll like steer in the right direction, but it's not as good as
    it is with Nex.js when you you you're using AI. And the second thing is Tanstack
    is still in release candidate, right? So, it's not even 1.0 version, and it's
    really difficult for me to ship something to production with something that's
    still in release candidate. So, we're using Nex.js as our front end. I use EliciaJS.
    Now, most of you might not be familiar with Alicia JS, but a simple way of thinking
    about it is if you're familiar with Hano, in my opinion, Alicia is better. It's
    basically a back-end framework. Think of how Express is for NodeJS, Alicia is
    for bun, but it also works with Node and I really like Alysia. Now, how do I use
    Alysia with Nex.js? Am I using it as a separate server? there is um a way instead
    of using the Nex.js default API, you can use Alysia as the backend on your Nex.js
    app. So you can see here it tells you with the nextJS app router, we can use Alisia
    on Next.js routes. All you would have to do is create an app/ API then have slugs/out.ts
    and then you literally copy this code and it's fantastic. And I'm actually just
    going to set this up with you real quick. So we're just going to spin up a simple
    uh Nex.js JS application. We're just going to call this demo video. We're going
    to use the recommended settings. So, our NexJS project has been set up. Now, I'm
    going to go back to Lisia JS. I'm just going to search Nex.js. And I literally
    just had it. Where'd it go? Right here. Integration with Nex.js. We're just going
    to follow these instructions. Let me open my project up in cursor real quick.
    We called it demo video. Let's just open this up in cursor. So, we have our NextJS
    project here. All that we're told to do is we need to create this file right here.
    So under the API route, uh, slugs.rod.ts, this is basically a catchall route.
    So basically what it does is any APIs that you write in Nex.js, the catch all
    route will catch them. That's why it's called catch all route. And we'll be using
    Alysia instead. So I'm just going to copy that. And then under app, we're going
    to create new file. We're going to paste that. And then we have our route created.
    And then I'm literally just going to paste this code right here. And we're going
    to binstall Alysia. And we're also going to just bun install everything else.
    And then the errors should disappear. Perfect. And what's cool about using Alysia
    within Nex.js is you can add Eden, which is basically their version of TRPC, which
    gives you endtoend type safety. So to set this up, all I have to do is create
    a treaty client. So I'm just going to copy this and under the lip folder, create
    an Eden.ts ts file. So I'm going to create a lib folder and underneath it we're
    going to do eden.ts. We're going to click paste here and then we're just going
    to install what we need to install. So bun install this package right here. So
    instead of type, we're going to just remove that type and make sure on the route.ts
    that app is exported. So we have that set up. Now that we have everything set
    up, I'm going to show you how amazing using Alisiajs is and how the type safety
    is going to help our AI. So whenever I want to call a route, all I have to do
    is import API from Eden. When I click on the period, you see that I have my get
    request, my post request. So it's fully type safe. I'm just going to type in the
    get request and I'm just going to close the brackets. And here's what's cool about
    using Alisia, right? I if I just console log this message right here. Let me console
    log message and I'm going to run this server. You're going to see what is returned
    in message. So let's go and localhost 3000. We're going to inspect console. So
    when we look at what's returned, we see the data hello world. We see the error
    return null. We see response. We see status 200. So what I can do is I can break
    up message and I can get the data, the error, the status, the response and you
    can do whatever you want with that information, right? I like Alicia for this.
    So yeah, when I use Nex.js, I make sure I use Alicia. But here's the thing, Alicia
    is not going to be my main backend. I'll use it for one-off routes or if there's
    a particular reason I need a Nex.js API, I will use that. But my backend of choice
    is Convix. Now, I already hear some of you, you're only mentioning Convix cuz
    you worked there. And I would agree with you if I didn't use it for every single
    project I build. Literally every project I use, I use Convex. And it's not because
    I work there. Well, first and foremost, I'm the one who reached out to them and
    said, "Give me a job cuz I love the product so much." But truth be told, it's
    the amount of things that Convex does for you. You need a database, a real-time
    database, you got it. You want a clean separation between your functions and your
    DB. You don't want to call your DB directly on the client, you got it. You want
    to be able to handle web hooks, you got it. You want to be able to handle crown
    jobs, you got it. You want to handle scheduled functions, scheduled jobs, background
    jobs, cues, any sort of job except getting a real job, you got it. So, Convex
    literally handles everything for me backend related and it's done right. Here's
    the thing about using Convex. It's not just a technical decision where yes, the
    DX is great, but it's also like from an AI perspective, the models are so good
    at writing convex code. And the reason being is I'm going to show you the reason
    actually. It's very simple. The reason why AI is great with Convex is I'm just
    going to set up Convex on this project. I'm going to run mpx convex dev. I'm going
    to create a new project. I already have an account set up. And watch this. Notice
    how a convex folder just popped up. Everything in convex, whatever setup configuration,
    whatever feature you want to use, you want to set up, you spin up a DB, you want
    to have scheduled jobs, whatever it is, all of it is code. If all of it is code,
    that means you can use the AI to build all these crazy things. I don't have to
    go to the dashboard and configure something or turn something on. All of it is
    code. Think of Terraform but for your back end. But it's all Typescript and it's
    all type safe and it's real time by default. Like the amount of highquality applications
    you can build at warp speed if you just make the decision to use Convex is astronomical.
    Like an example I'll give you just like a quick example. I I'm a big I'm a big
    personal finance guy. I love investing and one of the things that I do is like
    I really keep up with the markets, right? One thing that I wanted is I wanted
    to have my own personal dashboard where I can track like my portfolio but I can
    also track certain price levels, right? But I didn't want to go like on trading
    view all the time. I wanted to have just a simple mobile app. And this is how
    I built it. I basically used Trading View. I used Trading Views um Trading Views
    alerts, right? Right? I don't know why I'm writing this down, but I used Trading
    Views alerts. And basically, they have this feature where you can give them a
    web hook and they'll fire data to the web hook. And what I used was Convex. I
    had a Convex application set up. I had a Convex backend, right? Let me just write
    Convex over here. I had a Convex backend and then I had a Nex.js, you know, I
    was using Next.js for the front end, right? And basically what was happening was
    I set up a Convex web hook. I gave it to Trading View alerts. Trading View would
    fire the alert to Convex and because whenever something changes in the database
    and Convex automatically it updates on your front end because that is by default
    how convex works. I would get real time alerts on my Nex.js app on the mobile
    app on the expo app and all it took was npx convex dev right and setting up a
    web hook is as simple. If I go into the docs and I just search web hooks, you
    could see HTTP actions. It's as simple as setting that up right there. That's
    your web hook right there. It's so simple. It's so easy. It's fully type- safe.
    I can't imagine a world where I'm building applications without convex. And it
    just so happens that the AI loves convex a lot. Next up, Turbo Repo. If you're
    going to be using any sort of monor repo, you're building a mobile app and a web
    app, Turbo Repo is the obvious choice. And if I'm building a mobile app, I'm going
    to use Expo. I've played around a little bit with Swift UI, but um it's just for
    Apple. I want to be crossplatform or cross device. So Expo allows me to do that.
    And it's React, so it's just easy and simple to get started. Now, in terms of
    styling, I mean, it's pretty simple. Tailwind V4 and Chat CNN UI. And what I love
    about the direction Shatnui is going is I'll be honest, I usually start here.
    I'll go on shhats and UI and I'll click new project and then I can customize.
    Okay, I'll use base UI for the base component and then let's say I want the style
    to be more mirror where it's a little bit compact and the radius I want there
    to be none. I want it to be super boxy and maybe for the theme let's go a little
    emerald, a nice little green or maybe that feels a little too corpority. Let's
    go sky blue. Right? So I'll literally start here. I'll click create project and
    then I'll just run this bunx command. This is my starting port most of the time
    and Shadzian is my default styling library, component library, whatever you want
    to call it. Now, payments for payments, I'm using Stripe. And here's the thing,
    when you're using Convex, using Stripe or Polar or Autumn or Dodo Payments, whatever
    payment provider you want to use, it's super simple. And the reason why is Convex
    has this thing called components. And essentially components are independent modular
    TypeScript building blocks for your backend. So I can click on payments here and
    I have full components for Stripe, for Polar, for Autumn and for Dodo payments.
    By the way, someone really handsome is the one who made the Stripe component.
    I would know cuz it's big. But in all seriousness, the convex component takes
    care of everything for me. So let's say I wanted to use the stripe component.
    It's as simple as literally, let me just close this real quick. It's as simple
    as installing the component. And then what I would do is like literally, you can
    use AI for this. You can give AI the repo. Like you could literally create a new
    agent and be like, build out a subscription for me using Stripe, but using Convex's
    Stripe component. Here's the repo. And I would just let AI spin it up. And 10
    times out of 10, every time I've done this, it's got it absolutely right. So I
    like this is why again using Convex as a perk is a plus because there are a lot
    of these great components that exist. Let's say you wanted to build like some
    really durable workflows. You can use the workflow component. You can use the
    workpool component. There's a lot of these great components and integrations that
    you can use. Let's say I want storage. I can use Cloudflare R2. Let's say I want
    emails, right? I can use recent and all this code is already written for me. All
    I have to do is just install the component in my convinc. So yeah, for payments
    I'm using stripe. I haven't used autumn but to be honest if I had to do some usage
    based billing or some AI credit stuff billing I would use autumn. They have a
    convex component so it would make life easier. Now in terms of O there's clerk,
    there's work OS, there's better off. Here's how I think about it. I will say out
    of the three the easiest to set up is clerk. It's just I'm just be honest. I do
    like Better Off Barracks the homie. Uh and Better Off there's a lot of great integrations
    and they even have a convex component that's getting a lot of improvements and
    it might be my def facto but as of yet clerk is still the simplest to use. But
    if I wanted like some sort of enterprise solution, I was building an enterprise
    app. I'm 100% going for work OS. Here's the thing. You can't go wrong with any
    of these. I've used Better Off. I've used Clerk. I've used work OS. I use all
    three of them. But there are different reasons why I would pick one. All three
    solutions are great. Now, building AI apps. What I mean by this is what are the
    tools I would use when building AI apps. The first one I want to talk about is
    Daytona. I've been using Daytona a lot the last couple of days. And the reason
    why is I've been working on most of you if you've seen the previous video have
    seen Ralphie, which is basically Ralph on steroids. It's this uh autonomous loop
    basically running all sorts of agents autonomously. We're at 1.6k star. So, if
    you could give us a star, I would really appreciate it. That being said, the reason
    why I've been using Daytona is I want to wrap Ralphie and build an autonomous
    coding agent app where all you do is plan, you hit enter, and then it builds out
    the project end to end. Here's the app. It's called Sandstorm. So basically what's
    happening is we're spinning up cloud code agents in a Daytona sandbox and people
    are able to build applications in that sandbox. So instead of using their own
    personal file system, we're using Daytona's file system. We're using Daytona sandbox
    and I'll be honest, the developer experience for Daytona is absolutely the best.
    I've used a bunch of other sandbox providers, but nothing comes as close as Daytona.
    If you're building any sort of AI coding agent or AI agent application and you
    need access to a file system, I highly recommend use Daytona. I've been using
    it for Sandstorm and it's been fantastic. AI SDK. AI SDK is basically what I use
    to build all my agents. It's SDK by Versell. It's probably one of the most popular
    TypeScript AI SDKs. Very well supported, very well documented. Lots of tutorials
    on it. There's no reason why you shouldn't use it. The underdog though, or should
    I say the most slept on agent that people are using but not a lot of people are
    talking about is Claude's agent SDK because this agent SDK is cloud code, right?
    You can spin up cloud code instances. You can spin up cloud code agents um and
    you can have them do plethora of things whether you're building a coding agent
    or some sort of assistant or whatever it is. You take this agent SDK, you give
    it access to a sandbox, you can do a lot of amazing things, build a lot of amazing
    AI applications. So, highly recommend you use that. And then last but not least
    is Composio. Composio is basically my tool layer, right? So, let's say I wanted
    to build an AI application that has access to my Gmail or a customer's Gmail,
    my Google calendar, and a bunch of other tools, right? Slack, GitHub, Google Sheets,
    Shopify, Google Drive, like there are plenty of integrations you can give an AI
    like an agent and it would do extremely awesome things, right? But building that
    integration layer and all those tools and connecting all those tools is difficult.
    Compose abstracts that. It makes it so simple that with a few clicks and a bit
    of line of code like I'll show you. If we go to the docs, let's go to the overview.
    Let's say you're using AI SDK, right? It's as simple as initializing composio,
    right? You're going to have uh the user is going to have some sort of user ID.
    You're going to create a tool router session and then you literally give it access
    in stream text. So you see you have tools here. Now it has access to all the tools
    you've configured on the Composio dashboard. And there's hundreds, thousands of
    tools, and building that yourself is a headache. Composio is a no-brainer. Every
    time I build AI applications, I'm using all these tools. Now, deployments, where
    am I deploying my applications? There's two places really. Uh, for the most part,
    I'm using Verscell to deploy my NexJS applications, but there are instances where
    I'll need a separate server. And for that, I'm using Railway. Railway is absolutely
    amazing. I know they don't have a free tier, but the $5 is worth it. The DX is
    amazing. Let's like like let's say like I'm no fan of Postgress, but let's say
    I wanted to spin up a Postgress database, right? It's as simple as as follows.
    I'm going to click new. I'm going to click databases. I'm going to click Postgress.
    And it is spinning up a Postgress instance as we speak. And there you have it.
    I have a Postgress database, right? I can go to settings and configure whatever
    it is I want. I can get the database public URL. Meaning if I want to expose this
    to another service like if I have another backend server that I haven't deployed
    here, I can do that. But if I wanted to let's say deploy a server here, a back-end
    server that was going to communicate with this database, all I have to do is click
    create and say I wanted to deploy an Alysia bun server using Drizzle. I would
    click that. They have a template there and then I can basically deploy this Alicia
    server and connect it with this Postgress database and it's going to be so blazing
    fast because you're in the same deployment. I'm a big fan of railway especially
    if I need an external server or another server. Railway is my place to go. Now
    in terms of AI tools, there's a bunch of them. We're using cloud code. We're using
    cursor. Now some of you might be saying, why are you using cursor? There are actually
    times I like going back and forth with cursor. I do like the cursor agent itself.
    I hope you know cursor has their own CLI. Like if you didn't know, you can literally
    type I can type in agent and what pops up right here is going to be the cursor
    agent, the cursor CLI and it's pretty good. So I'll use the cursor editor because
    I like reviewing the code. I like writing code, but I'll also be using cloud code.
    For terminal, I'm using Ghosty. Ghosty is my terminal at choice. I just like the
    DX and all my hotkeys. It allows me to move really, really fast. But really the
    one I've been greenpilled or gravile pled on is GPile. And the reason being is
    AI code review has allowed me to ship much faster. I'm going to show you the Ralphie
    repo. And let's just pull up a pull request. Let's look at this right here. Fix
    Windows line ending handling and markdown task source. Right? So I see someone
    made a PR. They gave it a submar. There's a test plan. I'm going to look at the
    gravile overview. Here's how I analyze PRs. Now, if the confidence score is four
    out of five or greater or five out of five, then I'm reviewing. If it's not, I'm
    going to tell the person to address the comments. And almost every single time
    I've seen a five out of five, it is a perfect PR. It's a safe PR. And Graile has
    sincerely cut down the amount of time I've spent reviewing code that is just blah.
    And here's the thing, you can even be lazy with this. I can take this reptile
    review, pass it to the AI I'm using to build the application and say address the
    comments. And there are even places I don't know if I have maybe let's pull up
    this uh PR right here. There are places you can see here that Gravile will make
    comments and it will even offer suggestions. And there are times where it won't
    offer a suggestion, but it'll give you the prompt to pass to your AI for your
    AI to fix whatever the issue it flagged. So if you're building anything, especially
    if you're using AI, you 100% need to use Gravile. Gravile, in my opinion, is one
    of the best AI code reviewing tools. Now models, there's really two models for
    programming. I'm only using Opus 4.5 thinking. Codeex is cool. Um, there are times
    where it'll catch like very edge case bugs, but I'm using Opus most of the time.
    And the reason why I have Open AI here is I definitely do like 5.2 to for just
    everyday tasks, chatting and all that type of stuff. And speaking of chatting,
    what chat apps do I use? T3 Chat is my daily driver, but I also have a subscription
    to OpenAI and Claude. The reason why I have a subscription to OpenAI is I like
    Deep Research every now and then, and my wife uses it as well. And for Claude,
    I use Claude Co-work sometimes. But T3 chat is my daily driver. Ladies and gents,
    I know that was a pretty long video, but this is my entire techtool stack. I do
    plan on updating some of the templates I have on my GitHub repo for you guys to
    use easily, especially when you're building apps with AI. But I hope this made
    sense. I hope you enjoyed this video. I hope my decision- making and why I use
    specific tools matters. At the end of the day, it's very important that you understand
    these tools, right? I think one edge developers have over non-developers when
    using AI is we know what's good and what's not. We know what works and what doesn't.
    And it feels like we're entering an era of more engineering, less programming.
    Although I'm very sad about it, it is what it is. We have to adapt to the times.
    We have to be the best at what we do. And I hope you enjoyed this video. Make
    sure to like, comment, subscribe, hit the notification bell. I'll see you in the
    next one. Peace.
  segments:
  - start: 00:00:00
    text: With AI writing a good chunk of the
  - start: 00:00:01
    text: code, now more than ever, the tools we
  - start: 00:00:03
    text: use matter. That's why in today's video,
  - start: 00:00:05
    text: I'm going to be sharing with you all the
  - start: 00:00:07
    text: tools that I use, my web and mobile
  - start: 00:00:09
    text: frameworks, what I use for styling, what
  - start: 00:00:11
    text: I use for payments, what I use for
  - start: 00:00:12
    text: authentication, the tools I use to build
  - start: 00:00:14
    text: AI apps, where I deploy my applications,
  - start: 00:00:17
    text: the AI tools I use to build my
  - start: 00:00:18
    text: applications, what models do I use. Is
  - start: 00:00:20
    text: it just Opus 4.5 or is there another
  - start: 00:00:22
    text: model? What chat apps did I use? I'm
  - start: 00:00:24
    text: literally going to be sharing with you
  - start: 00:00:25
    text: my entire tech and tool stack that I use
  - start: 00:00:28
    text: when shipping apps using AI. We're going
  - start: 00:00:31
    text: to get in the weeds with this one. I
  - start: 00:00:32
    text: hope you're ready. I hope you're
  - start: 00:00:33
    text: excited. Let's get into it. So, first
  - start: 00:00:35
    text: things first, let's talk about the web
  - start: 00:00:37
    text: and mobile frameworks I use. What tools
  - start: 00:00:39
    text: do I use to build my web and mobile
  - start: 00:00:42
    text: applications? And for the most part,
  - start: 00:00:44
    text: this has been pretty standard. There is
  - start: 00:00:46
    text: a new addition to the pack, and I'll
  - start: 00:00:47
    text: explain why in a second. But I genuinely
  - start: 00:00:50
    text: believe with all these tools, I can ship
  - start: 00:00:52
    text: any web and mobile app. So if you've
  - start: 00:00:55
    text: been watching my YouTube channel, you
  - start: 00:00:56
    text: know that I've been a big fan of Nex.js
  - start: 00:00:58
    text: and I've been using Nex.js for quite
  - start: 00:01:00
    text: some time now. I know there's some of
  - start: 00:01:01
    text: you that are probably going to say, why
  - start: 00:01:03
    text: not Tanstack Start? And I've played
  - start: 00:01:05
    text: around with Tanstack Start. It's
  - start: 00:01:06
    text: actually really great. My only qualms
  - start: 00:01:08
    text: with it is there are actually two
  - start: 00:01:10
    text: things. First and foremost, the AI
  - start: 00:01:12
    text: models have not been trained on it. So
  - start: 00:01:14
    text: it definitely does hallucinate. Now, I
  - start: 00:01:16
    text: know you can probably add some skills or
  - start: 00:01:18
    text: some like example code or some snippets
  - start: 00:01:20
    text: and it'll like steer in the right
  - start: 00:01:21
    text: direction, but it's not as good as it is
  - start: 00:01:23
    text: with Nex.js when you you you're using
  - start: 00:01:25
    text: AI. And the second thing is Tanstack is
  - start: 00:01:28
    text: still in release candidate, right? So,
  - start: 00:01:29
    text: it's not even 1.0 version, and it's
  - start: 00:01:31
    text: really difficult for me to ship
  - start: 00:01:33
    text: something to production with something
  - start: 00:01:34
    text: that's still in release candidate. So,
  - start: 00:01:37
    text: we're using Nex.js as our front end. I
  - start: 00:01:40
    text: use EliciaJS. Now, most of you might not
  - start: 00:01:43
    text: be familiar with Alicia JS, but a simple
  - start: 00:01:46
    text: way of thinking about it is if you're
  - start: 00:01:48
    text: familiar with Hano, in my opinion,
  - start: 00:01:50
    text: Alicia is better. It's basically a
  - start: 00:01:52
    text: back-end framework. Think of how Express
  - start: 00:01:55
    text: is for NodeJS, Alicia is for bun, but it
  - start: 00:01:59
    text: also works with Node and I really like
  - start: 00:02:03
    text: Alysia. Now, how do I use Alysia with
  - start: 00:02:06
    text: Nex.js? Am I using it as a separate
  - start: 00:02:08
    text: server? there is um a way instead of
  - start: 00:02:11
    text: using the Nex.js default API, you can
  - start: 00:02:14
    text: use Alysia as the backend on your Nex.js
  - start: 00:02:17
    text: app. So you can see here it tells you
  - start: 00:02:19
    text: with the nextJS app router, we can use
  - start: 00:02:21
    text: Alisia on Next.js routes. All you would
  - start: 00:02:24
    text: have to do is create an app/ API then
  - start: 00:02:27
    text: have slugs/out.ts
  - start: 00:02:30
    text: and then you literally copy this code
  - start: 00:02:32
    text: and it's fantastic. And I'm actually
  - start: 00:02:33
    text: just going to set this up with you real
  - start: 00:02:34
    text: quick. So we're just going to spin up a
  - start: 00:02:36
    text: simple uh Nex.js JS application. We're
  - start: 00:02:39
    text: just going to call this demo video.
  - start: 00:02:42
    text: We're going to use the recommended
  - start: 00:02:43
    text: settings. So, our NexJS project has been
  - start: 00:02:45
    text: set up. Now, I'm going to go back to
  - start: 00:02:46
    text: Lisia JS. I'm just going to search
  - start: 00:02:48
    text: Nex.js.
  - start: 00:02:49
    text: And I literally just had it. Where'd it
  - start: 00:02:51
    text: go? Right here. Integration with Nex.js.
  - start: 00:02:53
    text: We're just going to follow these
  - start: 00:02:54
    text: instructions. Let me open my project up
  - start: 00:02:57
    text: in cursor real quick. We called it demo
  - start: 00:02:59
    text: video. Let's just open this up in
  - start: 00:03:01
    text: cursor. So, we have our NextJS project
  - start: 00:03:03
    text: here. All that we're told to do is we
  - start: 00:03:05
    text: need to create this file right here. So
  - start: 00:03:08
    text: under the API route, uh, slugs.rod.ts,
  - start: 00:03:11
    text: this is basically a catchall route. So
  - start: 00:03:13
    text: basically what it does is any APIs that
  - start: 00:03:15
    text: you write in Nex.js, the catch all route
  - start: 00:03:17
    text: will catch them. That's why it's called
  - start: 00:03:19
    text: catch all route. And we'll be using
  - start: 00:03:21
    text: Alysia instead. So I'm just going to
  - start: 00:03:23
    text: copy that. And then under app, we're
  - start: 00:03:26
    text: going to create new file. We're going to
  - start: 00:03:28
    text: paste that. And then we have our route
  segment_count: 592
  language: en
  is_auto_generated: true
processing:
  stage: ingested
  stages_completed:
  - ingest
  next_stage: extract
